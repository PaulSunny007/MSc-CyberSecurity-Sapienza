# Malware Analysis and Incident Forensics - Theory

- [Lesson 1 - Introduction](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-1---introduction)
- [Lesson 2 - The Attack Killchain part 1](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-2---the-attack-killchain-part-1)
- [Lesson 3 - x86 Assembly language (Lab)](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-3---x86-assembly-language-lab)
- [Lesson 4 - x86 Assembly language part 2 (Lab)](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-4---x86-assembly-language-part-2-lab)
- [Lesson 5 - More on the A.K. and the anatomy of an attack](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-5---more-on-the-ak-and-the-anatomy-of-an-attack)
- [Lesson 6 - x86 Assembly language part 3 (Lab)](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-6---x86-assembly-language-part-3-lab)
- [Lesson 7 - Basic Static Analysis - part 1](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-7---basic-static-analysis---part-1)
- [Lesson 8 - Models for Threat Intelligence](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-8---models-for-threat-intelligence)
- [Lesson 9 - Basic Analysis](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-9---basic-analysis)
- [Lesson 10 - Basic Dynamic Analysis](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-10---basic-dynamic-analysis)
- [Lesson 11 - Models for Threat Intelligence part 2](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-11---models-for-threat-intelligence-part-2)
- [Lesson 12 - Basic Dynamic Analysis (Lab)](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-12---basic-dynamic-analysis-lab)
- [Lesson 13 - Advanced Static Analysis Part 1](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-13---advanced-static-analysis-part-1)
- [Lesson 14 - Threat Intelligence example & Yara rules](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-14---threat-intelligence-example--yara-rules)
- [Lesson 15 - Advanced Static Analysis (Lab)](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-15---advanced-static-analysis-lab)
- [Lesson 16 - Advanced Dynamic Analysis](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-16---advanced-dynamic-analysis)
- [Lesson 17 - Cyber Threat Intelligence Sharing](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-17---cyber-threat-intelligence-sharing)
- [Lesson 18 - Advanced Dynamic Analysis (Lab)](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-18---advanced-dynamic-analysis-lab)
- [Lesson 19 - Code Packing](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-19---code-packing)
- [Lesson 20 - Code Packing (Lab)](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/theory.md#lesson-20---code-packing-lab)

## Lesson 1 - Introduction

General news about malware-based attacks:
- [Yahoo 'state' hackers stole data from 500 million users](https://www.bbc.com/news/world-us-canada-37447016)
- [Brian Krebs site hit with 665 Gbps DDoS attack; Largest Internet has ever seen](https://www.hackread.com/brian-krebs-website-665-gbps-ddos-attack/)
- [The Equifax data breach exposes extremely
sensitive data from 143 million consumers](https://www.bloomberg.com/news/articles/2017-09-07/equifax-says-cyber-intrusion-affected-143-million-customers)

The data breach market is ourishing. Black markets provide advanced tools for data search. Prices are extremely variable depending on the specific product.

The topic of this course revolves around *Cyber Security*:  
“preservation of confidentiality, integrity and availability of information in the Cyberspace” (ISO-27000)  
Cyberspace is “the complex environment resulting from the interaction of people, software and services on the Internet by means of technology devices and networks connected to it, which does not exist in any physical form” (NIST)

The role of malware  
![malware types](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/01-malware-types.jpg)  
Source: https://www.gdatasoftware.com/blog/2018/09/31037-malware-figures-first-half-2018-danger-web

The **Attack Killchain** is a list made of 8 points explaining the anatomy of a malware:  
- Reconnaissance
- Weaponization
- Delivery
- Exploitation
- Persistence
- Callback
- Data exfiltration
- Lateral spread

In this course we will go deep in the last 4 points.

Expected behaviours:
- Persistence
    - The malware installs itself in the system
    - It performs actions to guarantee its survivability to reboots, inspections, etc.
    - Often modifies the OS configuration
    - Changes are hidden
- Uniqueness
    - Malware is often incompatible with itself
    - Multiple concurrent executions are meaningless
      - Or sometimes dangerous for the malware itself
      - Think about two ransomware instances competing for the same resources
    - Checks at startup guarantee te execution of a single copy
- Obfuscation and evasion
    - Malware will try to hide its presence and its effects to stay undetected as long as possible
    - It may inject code in the processes to conceal its real identity
    - It may mangle its internal code to hide easily discoverable hints of its malicious nature
    - It may leverage techniques to hamper the possibility to correctly analyze its behavior
- Fingerprinting
    - Malware will inspect the infected system and collect information about it
    - Information can be used to “publicize” its presence to a remote server
    - Sometimes the malware may locally use this information to control its own behavior
        - e.g. fully deploy its payload only in a specific country, or at a specific date
- Communication
    - Malware often interact with external command & control services to
        - receive instructions and commands
        - update its internal components
        - exfiltrate data
    - Communication may use an impressively heterogeneous set of links
    - Data on channels is often obfuscated

## Lesson 2 - The Attack Killchain part 1

The 5 Ws of a CyberAttack:

| W | Answer |
|-----------------|--------------|
| Who | Targets: Single users, Industries, Financial, Health, Energy, IT, Manufacture, Public agencies, MIL & Defense.  Threats: Hackers, Activists, Undercover operations, Industrial espionage, Cyberterrorists, Cyberwarfare.  Other actors: Research (academia, agencies, individuals), Security firms and experts, White-hat hackers, CERTs and government agencies, MIL & Defense. |
| What | Activities of interest: Data theft, Machine control, Financial fraud, Disruption of operation, Defacing, Physical damage. |
| Why | Motivations: Financial gain, Politics/ Hacktivism, Doxing, Terrorism / Cyberwarfare, Revenge |
| Where and When  | https://cybermap.kaspersky.com |

The evolution of Malware:
- 1998 CIH (https://en.wikipedia.org/wiki/CIH_(computer_virus))
- 2001 Code Red (https://en.wikipedia.org/wiki/Code_Red_(computer_worm))
- 2003 Slammer (https://en.wikipedia.org/wiki/SQL_Slammer)
- 2004 MyDoom (https://en.wikipedia.org/wiki/Mydoom)
- 2005 PoisonIvy (https://en.wikipedia.org/wiki/PoisonIvy_(trojan))
- 2007 Zeus (https://en.wikipedia.org/wiki/Zeus_(malware))
- 2008 Agent.btz (https://en.wikipedia.org/wiki/Agent.BTZ)
- 2010 Stuxnet (https://en.wikipedia.org/wiki/Stuxnet)
- 2010 DigiNotar (https://en.wikipedia.org/wiki/DigiNotar)
- 2012 Flame (https://en.wikipedia.org/wiki/Flame_(malware))
- 2017 Wannacry (https://en.wikipedia.org/wiki/WannaCry_ransomware_attack)
- 2017 Petya (https://en.wikipedia.org/wiki/Petya_(malware))
- A growing trend (http://www.informationisbeautiful.net/visualizations/worlds-biggest-data-breaches-hacks/)

The production chain of malware:
1. Malware coder writes malicious software to exploit a computer vulnerability and install a trojan.
2. Victim infected with credential-stealing malware.
3. Banking credentials siphoned.
4. Hacker retrieves banking credentials.
5. Remote access to compromised computers.
6. Hacker logs into victim's online bank account
7. Money transferred to mule.
8. Money transferred from mule to organizers.

Read also the [Verizon 2021 Data breach investigations report](https://www.verizon.com/business/resources/reports/dbir/2021/).

## Lesson 3 - x86 Assembly language (Lab)

We will focus on Windows malware, the most dominant OS by far.  
We could see some malware written in Powershell or even Python, but in most cases the malware samples are written in binary code.  
Binary code is a coding system using the binary digits 0 and 1 to represent a letter, digit, or other character in a computer or other electronic device.  
Obviously is the most low level code we could have and we are interested in reverse engineering it.  
Decompilers (e.g., Ghidra, Hex-Rays, rev.ng, Snowman) try to reconstruct a high-level C-like representation of binary code. Process far from perfect:
- information loss during compilation (e.g., types)
- for an obfuscated code you get an obfuscated source...
- anti-analysis techniques

Nonetheless, decompilers are useful when reverse engineering.  

In CPUs there are registers that have the purpose of storing tiny portions of information useful to be retrieved in a very fast way by the processor.  
Instruction Set Architecture (ISA) = abstract model that describes what a programmer should know to program a machine
**ISA** ≈ interface between software and hardware. Humans/compilers produce ISA-conformant assembly code, then an assembler encodes it in a binary format understood by hardware.  
- Intel defined the x86 ISA for its 8086 processor
- 1976-1978. Additions and extensions preserved backward compatibility
- Also known as IA-32. Today most malware is still 32-bit
- x86-64 (x64 for short) is the 64-bit successor

A word is the natural data unit for a specific CPU design. For x86 processors, the word size is 32 bits.  
However, for backward compatibility, x86 instructions assume a word operand to be 16-bit long, while a dword operand is 32-bit long.  
IA32 common data types: byte, word, dword.  
Memory always operates at byte level. Endianness specifies how multi-byte sequences are read from/written to memory.  
![endianness](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/02-endianness.png)

Registers are memory units CPU uses for fast retrieval of data.  
Coders use (many) variables. CPUs work on (few) registers. x86 general-purpose registers are 32-bit wide.  
Registers hold data with fast access time:
- General-purpose registers (GPRs) can store data or memory addresses
- Status register holds truth values on the state of the processor from past computations (used e.g. for conditional computations)
- Program counter holds the address of the instruction being executed
- Many other registers

![accessing registers](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/03-accessing-registers.png)  
Credits: Yale's CS421

Program counter EIP (Instruction Pointer) and status register EFLAGS cannot be accessed directly.  

This is the instruction cycle (Fetch-decode-execute cycle):  
- *Fetch*: CPU reads instruction from address stored in EIP
- *Decode*: control unit determines meaning of the instruction
- *Execute*: carry out computation using ALU or move data
- Then EIP advances to the next adjacent instruction, unless current instruction explicitly altered the control flow (e.g., with a jump)
Instructions have variable size (1-15 bytes) and are stored in memory consecutively, along with any immediate operands (data or addresses) they might use. Register operands are captured instead by the opcode binary representation:
~~~
b8 01 00 00 00      mov eax, 0x1
bf 01 00 00 00      mov edi, 0x1
~~~

Addressing modes provide a way to express the addresses of data to be read from/written to the main memory.  
Expressions can take immediate operands, registers, or both.  
Addressing modes enable operand combinations to compute complex expressions that depend on the program state.  
Usually, an instruction can have at most one memory operand (no memory-to-memory operations allowed).

Some popular ways to specify data to be read from/written to the main memory. For the last two rows the offset field is optional:
| Mode | Intel syntax |
| ---- | ---- |
| Immediate | `mov eax, [0x1000]` |
| Register | `mov eax, [esi]` |
| Register + offset | `mov eax, [esp-8]` |
| Register * width + offset | `mov eax, [ebx*4+0xff]` |
| Base + Register * width + offset | `mov eax, [edx+ebx*4+8]` |

![Intel memory map of a process](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/04-memory-map-process.png)

There are some security mechanisms to prevent weird and dangerous things to damage the memory and the host. 
- Paging mechanisms
    - determine whether an address is valid
    - enforce read/write/execute permissions on regions
    - pages in kernel space are accessible from kernel code only
- Operating systems may enforce high-level security mechanisms to hinder memory vulnerability exploitation attacks
    - DEP (Data Execution Prevention)
    - ASLR (Address Space Layout Randomization)
    - Heap allocation randomization & other protections in Windows 10

**Basic x86 instructions**  
Programs are written using three kinds of instructions:  
- Data movement
- Arithmetic & logic
- Program flow control

*Data movement instructions* are straightforward
- `mov dest, src` Copy {register, memory content, immediate} to {register, memory location}
- `push src` Used for stack manipulation
- `pop dest` Used for stack manipulation

*Arithmetic instructions* are relevant for code analysis for many reasons:
- computing oﬀsets and function addresses
- stack pointer modifications
- used like data movement ones or to update EFLAGS

- `add dest, src`: dest += src
- `sub dest, src`: dest -= src
- `inc dest`: ++dest
- `dec dest`: --dest
- `not dest`: 1's complement
- `neg dest`: 2's complement

Then we have *logic instructions*, some common instances:  
- zero-ing registers: xor eax, eax
- extracting bits and checking conditions
- obfuscation

Beware that these operations are bit-wise. High-level logical operations such as && and || have a diﬀerent semantic.  
- `and dest, src`: bitwise AND
- `or dest,src`: bitwise OR
- `xor dest, src`: bitwise XOR

We have also *rotate/shift instructions* (when src is absent, a default of 1 is assumed):
- `shr dest, src` and `shl dest, src`: Unsigned shift (right/left)
- `sar dest, src` and `sal dest, src`: Signed shift (right/left)
- `ror dest, src` and `rol dest, src`: Rotate (right/left)
- `rcr dest, src` and `rcl dest, src`: Rotate with carry (right/left)

Finally we have *program control flow instructions*:
- Control flow can be implemented in three ways
    - *Unconditional branch*: EIP is overwritten with some desired address
    - *Conditional branch*: EIP is overwritten with some desired address depending on the value of one or more bits from EFLAGS
    - *Function calls and returns*: special kind of unconditional branches
- Two ingredients needed
    - a means to specify the target of a branch (static or dynamic)
    - a means to evaluate a condition on the program state
- Code locations in assembly can be annotated with labels

An *unconditional branch* can take as destination:
- an oﬀset, specified as a relative oﬀset from the current EIP value or as an absolute oﬀset (from the base of the current code segment...)
- or an absolute address, provided as a register or memory operand
![Unconditional branch](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/05-unconditional-branch.png)

*Conditional branches* evaluate conditions over selected bits of the EFLAGS register. Common cases:  
- CF (carry flag), meant for errors in unsigned arithmetics
- OF (overflow flag), meant for errors in signed arithmetics
- SF (sign flag), set when the result of an operation is negative
- ZF (zero flag), set when the result of an operation is zero

To compare two values we can use the cmp instruction. `cmp dest, src` computes the diﬀerence dest-src without modifying dest, and sets the flags above in a way that allows for many useful comparisons...  
A *Jcc* instruction checks the condition specified by *cc* suﬃx and jumps to the given oﬀset (no absolute addresses) accordingly  
Say we just executed `cmp D, S`:
|  | Jump to L if | Negated version |
| ---- | ---- | ---- |
| `je L`; `jz l` | D==S | [D!=S] `jne L`; `jnz L` |
| `jg L`; `jnle l` | D>S | [D<=S] `jng L`; `jle L` |
| `jge L`; `jnl l` | D>=S | [D<S] `jnge L`; `jl L` |
| `ja L`; `jnbe l` | > with unsigned operands | `jna L`; `jbe L` |
| `jae L`; `jnb l` | >= with unsigned operands | `jnae L`; `jb L` |

Another instruction commonly used in comparisons is *test*, it computes the bitwise AND of its operands without altering them.  
Let's say we want to check whether register D holds zero as value, `test D, D` will set the zero flag iﬀ. D==0, then *jz* can be used.  
Beware that malware won’t use only *cmp* and *test* (e.g. you can decrement a value with *dec* or *sub* and then check if the instruction set the zero flag with *jz* (also optimizing compilers do that!).  

**Function** is a unit of code that controls register values and its portion of stack independently of other units.  
- if a code unit calls another, the latter should not clobber registers in use
- a CPU comes with few general-purpose registers: one may want to spill (i.e., save) some values on the stack and fetch them later in the execution

The stack is conceptually divided into frames, one per currently active function. A frame usually includes:
- the arguments for the function invocation
- local function variables and other storage
- return address for the call (i.e., where to resume execution upon function exit)

Suppose we do not have free registers left, and we would like to add to EDX the diﬀerence between EBX and ECX:
![Local storage](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/06-local-storage.png)

`push src` moves the top of the stack up by 4 bytes, then copies the content of the operand (immediate or register) to the address pointed by the updated ESP.  
`pop dest` copies the 4 bytes currently pointed by ESP to the dest register, then moves the top of the stack down by 4 bytes.  
push/pop operations can also be realized via sub/add + mov:  
~~~
push ebp
xor ecx, ecx
pop edx
~~~
Can be written as:
~~~
sub esp, 4
mov [esp], ebp
xor ecx, ecx
mov edx, [esp]
add esp, 4
~~~

When entering a function that makes use of local variables, register EBP can be used to reference their locations via fixed oﬀsets.
![Base pointer](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/07-base-pointer.png)

**Lab activity**: Introduction to IDA disassembler, analysis of some basic compiled binaries from C code.

# Lesson 4 - x86 Assembly language part 2 (Lab)

A code piece may invoke a function using the call instruction. Unlike jumps, before the control transfer takes place it stores on the stack the address of the instruction that follows it. This address is called the *return address* for the call. The callee can fetch it using `ret` and resume execution in the caller: this instruction will populate EIP with the address read from the top of the stack.  
Functions exists only at a logical level, their code is laid out in memory without special "separators". An adversary may scramble their layout, making it hard to identify function boundaries!  
During a function execution everything can happen, for example the code can modify some registers that should be use later...  
(At least) two questions left:  
- How are register values preserved across function invocations?
- How are parameters being passed to functions?

**Calling conventions** regulate:
- how parameters are passed (via registers/stack) and in which order
- which registers the callee must preserve for the caller
- who performs ESP realignment upon return
- Malware may use custom calling conventions for its functions, but has to follow standard ones to interact with Windows APIs.

**Calling conventions - Windows**
Diﬀerent conventions can be used in the same program  
*cdecl (C programs)*  
- arguments pushed on the stack, right-to-left order
- caller saves EAX, ECX, and EDX when in use (i.e. free for callee, which then has to preserve EBP, EBX, EDI, and ESI whenever it needs to use them)
- caller adjusts ESP after return
- 32-bit return value stored in EAX

*stdcall (Win32 API)*
- arguments, caller/callee-save registers and return value as in cdecl
- callee adjusts stack pointer on return
- ret N instruction is used, where N indicates to add N+4 bytes to ESP after EIP is updated

Example: **CDECL**  
![cdecl](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/08-cdecl.png)

For **STDCALL** is the same, but at the end of *subtract* function we have `ret 8` and we don't have `add esp, 8` after `call subtract`.  

*Caller-save* registers are pushed to the stack before a call, if the caller is going to use their values after the call (typically EAX, ECX, EDX).    
*Callee-save* registers are pushed to the stack in the prologue of the callee when it needs to use them (typically EDI, ESI, EBX).  
Compilers often prefer callee-save registers for performance: when register pressure gets high also caller-save registers are used. But in custom code we can find any sort of assortment...  

When used as base pointer a function prologue may set EBP with:
```
push ebp
mov ebp, esp
```
This can be done with a single instruction: `enter`.

To leave a function ESP must point to the caller’s return address. In the epilogue EBP can come to the rescue:
```
mov esp, ebp
pop ebp
```
This can be done with a single instruction: `leave`.

*LEA* (Load Eﬀective Address) evaluates an expression that defines a memory address and writes it to a destination register
- data movement and ALU instructions dereference a given address and operate on the content of the pointed location
- LEA simply computes an address!

Two uses:
- address calculation (pointer arithmetic)
- arithmetic expressions

Suppose EBX=0x1000, and 0xABADCAFE is stored at 0x1004.
- `mov eax, [ebx+4]` will copy 0xABADCAFE to register EAX.
- `lea eax, [ebx+4]` will copy 0x1004 to register EAX.

Source operands for LEA are not necessarily addresses... Suppose EAX=10, EBX=4 and we have to compute C=A+2\*B-1. `lea ecx, [eax+2*ebx-1]` will do the trick with a single instruction!  
Constraint: width for multiplication has to be 1, 2 or 4.

**REP instructions**  
Special instructions for manipulating bytes in buﬀers
- `cmpsb` to compare bytes from two buﬀers
- `stosb` to initialize all bytes in a buﬀer with same value
- `movsb` to copy one buﬀer into another
- `scasb` to search a byte in a buﬀer

They are preceded by a REP prefix: it repeats the operation until ECX == 0 or an additional condition on ZF is verified. EDI contains the address of the first buﬀer (destination), ESI contains the address of the second buﬀer (source), and AL contains the byte to set/search.  
We can implement the memcmp, memset, memcpy and memchr C functions using just the instructions above.

More hands on. Tests on Windows VM with IDA.

## Lesson 5 - More on the A.K. and the anatomy of an attack

We have the concept that an 'attack' is mainly made by people outside of the target and attacking the system breaching the border defenses and entering into. It's not so true, more and more attacks are changing this concept.  

Most dangerous attacks are today characterized by
- Precise targeting
    - Mass campaigns vs. precise targeting
- Full control of target (RAT)
    -  Remote access + privilege escalation
    - Multi-step attacks and compromisations
    - The attacker aims to fully control targets
- Long-term persistence (APT)
    - Multiple backdoors (Some of them may stay silent to provide backup entrance after target recovery)
    - Activity obfuscation
    - Security measure sidesteps + evasion

The **Intrusion (Attack) Killchain** is always the same:
- Recoinnassaince
- Weaponization
- Delivery
- Exploitation
- Persistence
- Callback
- Data exfiltration
- Lateral spread

**Reconnaissance**  
- Definition of the target surface
- The attacker looks for the best strategy to apply
- Target pro ling
    - Through social media
    - Public data sources
    - Doxing attacks
- Widely underrated phase of an attack

**Weaponization**  
A theoretical attack (or proof-of-concept) is transformed in running code. We need a feature having either a bug or undesired/non-designed/undocumented functionalities.  
- This is the step that requires strong technical skills
- Often "outsourced"
- Unknown vulnerabilities are extremely valuable
    - 0-day exploits
    - Sold for hundreds of $ on black markets
    - Valuable as long as they remain secret

**Delivery**  
The exploit is delivered through a vector (Email 93%, Web 6%, other 1%).
- phishing
- spear phishing
- watering hole

Technologies:
- EXE
- DOC, XLS, etc.
- PDF
- Javascript
- ZIP
- Flash
- Other

**Exploitation**  
Attack methods:
- 0-day exploit
- known software vulnerability
- misconfiguration
- bad user behavior

**Persistence** (and Installation)  
- Payload download
- Payload must be obfuscated while it trespasses boundary security
    - Secure channels
    - Code obfuscation and polymorphism
    - Encryption
    - Steganography
    - Use your imagination (tweets, Facebook messages, etc.)

Example: downloader.BMP.exe uses steganography to encrypt commands in a BMP file header.

Example: TROJAN.MSIL.BERBOMTHUM.AA
- uses steganography to hide commands in JPG images 
- pictures are distributed through social accounts (Twitter)

**Callback**  
- After installation the payload cleans up what remains of the infiltration procedure
- It may leverage local exploit to escalate local privileges
- Detecting the intrusion from this moment may be extremely di cult
- The payload contact a C&C server to
    - receive further instructions
    - download modules
- The communication is obfuscated as well

**Data exfiltration**  
- Any information in a single PC is potentially valuable
    - Passwords
    - private encryption keys
    - Documents
    - Information about the surrounding network
- Once the malware obtained administration privileges it can do whatever you may imagine:
    - install and use further software
    - impersonate you
    - act as a proxy
    - monitor the surrounding environment with your webcam

**Lateral spread**  
- Your PC may just be an access point to a larger network
- The attacker will take his time and explore his surrounding to in ltrate further resources
- The attacker is there to stay as long as possible

How much does it take for each step?
- Reconnaissance -> days/months
- Weaponization -> days/months
- Delivery -> minutes/hours
- Exploitation -> milliseconds
- Persistence -> years
- Callback -> years
- Data exfiltration -> years
- Lateral spread -> years

## Lesson 6 - x86 Assembly language part 3 (Lab)

Exercises using IDA disassembler.  

- Recognize stdcall and cdecl calling conventions
- REP instructions
- Self modifying code

## Lesson 7 - Basic Static Analysis - part 1

The goal of Malware Analysis.  
Information required to contain/mitigate a network intrusion
- Understand what exactly happened
- Make sure you’ve located all infected machines and les
- Understand how to measure and contain the damage
- Find indicators of compromise (IoCs)
- Build rules for intrusion detection systems

Dissecting malware to understand (A critical part of incident response!)
- How it works
    - Know your enemy’s strategies
- How to identify it
    - Extract signatures/IoCs (Indicators of compromise)
    - Prevent further similar infections
- How to defeat or eliminate it
    - Rollback (if possible) its e ects
    - Clean the infected system

**Signatures**  
- Host-based signatures
    - Identify les/processes/registry keys on a victim computer that indicate an infection
    - Focus on what the malware does to the system, not the malware itself
        - Behavioural analysis. Di erent from antivirus signature!
- Network signatures
    - Detect malware by analysing network tra c
        - Does the malware inspect the surroundings?
        - Does the malware contact an external Command & Control (C&C or C2) server?
    - More effective when coupled with malware analysis

**Stay safe:**  
- Keep a safe offline backup of your important data
- Always perform analysis on a virtual machine
- Keep a safe offline backup of your important data
- Disconnect the virtual machine from the network unless netcomms are necessary
- Keep a safe offline backup of your important data
- If you nd references to external IP addresses NEVER EVER try to directly contact them
- and ... keep a safe offline backup of your important data

**Static Analysis**  
- Examines malware without running it
- Tools: strings, PE inspection tools, a disassembler like IDA Pro, etc.

**Dynamic Analysis**  
- Run the malware and monitor its effects
- Use a virtual machine and take snapshots
- Tools: RegShot, Process Monitor, Process Hacker, CaptureBAT, debuggers,…
- RAM Analysis: Mandant Redline and Volatility


Basic static analysis: View malware without looking at its code. Tools: strings, PE inspection, etc. Quick and easy but fails for advanced malware and can miss important behaviour.  
Basic dynamic analysis: Easy but requires a safe test environment. Not effective on all malwares.  

Advanced static analysis: Reverse-engineering the malware code with a disassembler. Complex, requires understanding of assembly code and how such code interacts with the OS.  
Advanced Dynamic Analysis: Run code in a debugger. Examines internal state of a running malicious executable and how such state evolves.

**Types of malware**  
- Backdoor: Allows attacker to control the system
- Botnet: All infected computers receive instructions from the same Command-and-Control (C2) server
- Downloader
    - Malicious code that exists only to download other malicious code
    - Used when attacker first gains access
- Information-stealing malware: Sniffers, keyloggers, password hash grabbers
- Launcher
    - Malicious program used to launch other malicious programs
    - Often uses non-traditional techniques to ensure stealth or greater access to a system
- Rootkit
    - Malware that conceals the existence of other code
    - Designed to deeply hide in the infected machine to evade detection
        - User-level
        - Kernel-level
        - Bootkits
    - Usually paired with a backdoor or other functionalities
- Scareware
    - Frightens user into buying something
    - Ask for Ransom
- Spam-sending malware: Attacker rents machine to spammers
- Worms or viruses: Malicious code that can copy itself and infect additional computers

**Expected behaviors**  
- Uniqueness
    - Malware is often incompatible with itself
    - Multiple concurrent executions are meaningless
        - Or sometimes dangerous for the malware itself
        - Think about two ransomware instances competing for the same resources
    - Checks at startup guarantee the execution of a single copy
- Environment checks
    - Malware is designed to work in appropriate environment
    - Checks at startup if speci c execution conditions are met (Time/date, Localization, Availability of specific resources, etc.)
- Persistence
    - The malware installs itself in the system
    - It performs actions to guarantee its survivability to reboots, inspections, etc.
    - Often modifies the OS configuration
    - Changes are hidden
- Obfuscation and evasion
    - Malware will try to hide its presence and its e ects to stay undetected as long as possible
    - It may inject code in other processes to conceal its real identity
    - It may mangle its internal code to hide easily discoverable hints of its malicious nature
    - It may leverage techniques to hamper the possibility to correctly analyse its behaviour
- Fingerprinting
    - Malware will inspect the infected system and collect information about it
    - Information can be used to "publicize" its presence to a remote server
- Communication
    - Malware often interacts with external command & control services to
        - receive instructions and commands
        - update its internal components
        - exfiltrate data
    - Communication may use heterogeneous links types
    - Data on channels is often obfuscated

You don’t need to understand 100% of the code. Focus on key features, try Several tools and if one tool fails, try another one. Don’t get stuck on a hard issue, move along. Malware authors are constantly raising the bar.  

**Basic Static Analysis**  
Techniques: Antivirus scanning, hashes, a file's strings, functions and headers.  
Malware can easily change its signature and fool the antivirus. [VirusTotal](https://www.virustotal.com/gui/home) is convenient, but using it may alert attackers that they’ve been caught.  
MD5 or SHA-1 condenses a file of any size down to a fixed-length fingerprint. Uniquely identifies a file. De-facto standard way of uniquely identifying samples.  
Hash uses:
- Label a malware sample
- Share the hash with other analysts to identify malware
- Search the hash online to see if someone else has already identified the file

*strings*. 
Any sequence of printable characters is a string. Strings are terminated by a null value (0x00). ASCII characters are 8 bits long, while unicode characters are 16 bits long.  
The `strings` command is native in Linux/OSX, but it is also available for Windows. It prints all the printable strings in a file (3 or more chars long).
```
$> strings bp6.ex_
VP3
VW3
T$@
D$4
99.124.22.1     // [ 4 ]
e-@
GetLayout   // [ 1 ]
GDI32.DLL   // [ 2 ]
SetLayout   // [ 3 ]
M}C
Mail system is invalid.!Send Mail failed to send message.   // [ 5 ]
```

- (1,2) GetLayout and SetLayout are Windows functions
- (3) GDI32.DLL is a Dynamic Link Library
- (4) looks like an IP address
- (5) looks like an error msg

*Obfuscation through packing*  
The code is compressed, like a Zip file. This makes most strings and instructions unreadable. All you'll see is the wrapper (small code that unpacks the file when it is run).  
We can detect the type of packer used with PEID program, but sometimes malware creators use "proprietary" copies to avoid detection.  
Beware! Some PEiD plugins may silently run the malware to identify the packer, so take care of isolating your testing VM.  

*File execution in Windows*  
What happen when you double click an executable file in Windows? The OS (actually the loader) looks in the file to understand what to do.
What’s in the file?
- Code
- Data
- Other resources
- Metadata

All these information need to be organised to be correctly interpreted by the loader.  
Windows uses the **Portable Execution** file format.  
- Used by Windows executable files, object code, and DLLs.  
    - Very convenient! A single file format for several different usage scenarios
    - Means that you treat EXEs and DLLs in a very similar way
- A data structure that contains the information necessary for Windows to load the file
- Almost every file executed on Windows is in PE format

![PE file format](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/09-pe-format.png)

The sections that are most commonly present in an executable are:
- Executable Code Section, named *.text* (Microsoft) or *CODE* (Borland)
- Data Sections, named *.data*, *.rdata*, or *.bss* (Microsoft) or *DATA* (Borland)
- Resources Section, named *.rsrc*
- Export Data Section, named *.edata*
- Import Data Section, named *.idata*
- Debug Information Section, named *.debug*

The names are actually irrelevant as they are ignored by the OS and are present only for the convenience of the programmer.  
Means you can find very different names (e.g. packers use their names).


## Lesson 8 - Models for Threat Intelligence  
Most dangerous attacks are today characterized by
- Precise targeting
- Use of advanced intrusion/obfuscation techniques
- Full control of target (RAT)
- Long-term persistence (APT)

The attacker (threat) has enough motivations/resources/skills to try to attack its target for prolonged periods of time, using several approaches.  

![cyber threat intelligence](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/10-cti.png)  
An effective threat intelligence process has the main purpose of characterizing threats in order to identify valuable preventative controls.  
- Identify attackers
- Profile attackers
- Identify key tactics
- Rebuild playbook
- Replay playbook
- Utilize results

Goals at several levels:
- Strategic: Provide understanding of identified and credible threats, correlated to business impact
- Operational: Enable formulation of approaches to dealing with threats and prioritization of team activity
- Tactical: Provide understanding of how to mitigate threats and enable tools to do the heavy lifting

How do we make intelligence "actionable"?
- We assume the attack is resource constrained and behaves like a rational human being
- Cost factors
    - expertise, time, money, resources
- Success factors
    - target ubiquity, probability, access
- Value for the attacker comes from the possibility of re-using attack methodologies/techniques/tools as much as possible

*Repeatability*: the capability to change the target and have the attack still work with the same success rate.
*Scalability*: the capability to launch the attack against multiple targets with minimal cost per additional target.

Attackers determine the least costly and most valuable attacks based on
- Who are the targets
- Required success rate
- Speed of conversion

Inexpensive, valuable, scalable, or repeatable: Phishing, Credential reuse, Known vulnerabilities with public exploits, Office macros, Spyware, Vendor compromise.  
Costly, valueless, unscalable, or unrepeatable: Web vulnerabilities, 0-day exploits, Known vulnerabilities without public exploits, Embedded devices, Crypto weaknesses, Insider threat.  
The kill chain is not just a way to represent attacks, but rather a methodology to analyze (tentatives of) intrusions to extract actionable information (intelligence).  

The fundamental element of intelligence in this model is the indicator.  
**Indicator**: any piece of information that objectively describes an intrusion.  
Three types of indicators
- Atomic: those which cannot be broken down into smaller parts and retain their meaning in the context of an intrusion. (e.g. IP addresses, email addresses, vulnerability identifiers, etc.)
- Computed: those which are derived from data involved in an incident. (e.g. hash values)
- Behavioral: collections of computed and atomic indicators, often subject to qualification by quantity and possibly combinatorial logic. (e.g. "the intruder initially used a backdoor which generated network traffic matching regular expression at the rate of some frequency to some IP address")  

Indicators can be used to describe/identify various stages of the intrusion using the kill chain as a reference model.  

| Phase | Indicators |
| ----- | ----- |
| Reconnaissance | Benign File: tcnom.pdf (Recipient List) |
| Weaponization | Trivial encryption algorithm: Key 1 |
| Delivery | dn...etto@yahoo.com Downstream IP: 60.abc.xyz.215 Subject: AIAA Technical Committees (Email body) |
| Exploitation | CVE-2009-0658 (shellcode) |
| Installation | C:\...\fssm32.exe C:\...\IEUpd.exe C:\...\IEXPLORE.hlp |
| C2 | 202.abc.xyz.7 (HTTP request) |
| Actions on Objectives | N/A |

The intrusion killchain becomes a model for actionable intelligence when defenses align enterprise defensive capabilities to the specific processes an adversary undertakes to target that enterprise.  
![Course of action](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/11-course-of-action.png)  
Strategies to counteract intrusions:
- Detect: set up detection rules of an indicator for future events. (e.g. rules in an intrusion detection system (IDS), firewall or alert on SIEM)
- Deny: prevent the event from taking place. (e.g. firewall block)
- Disrupt: make the event fail as it is occurring. (e.g. file quarantining or memory protection measures)
- Degrade: slow down the further actions of the attacker. (e.g. bandwidth throttling)
- Deceive: learn more about the intentions of the attacker by making them think the action was successful. (e.g. use an honeypot)
- Destroy: offensive action against the attacker. (think twice about it...)

Recurring attacks from persistent threats require deeper understandings. Compare intrusion indicators to find commonalities.  
Infection points among diverse intrusions may represent common patterns in a long-term campaign. Such patterns can be used to uniquely identify threat actors.  

## Lesson 9 - Basic Analysis

The **Portable Execution** file format starts with a MS-DOS header + stub, just for compatibility. The PE headers contain metadata used to correctly load and execute the file. File content is structured in "sections", each section contains a specific kind of data. The section table describes the sections. Usually at least two sections are present.  
The sections that are most commonly present in an executable are:
- Executable Code Section, named *.text* (Microsoft) or *CODE* (Borland)
- Data Sections, named *.data*, *.rdata*, or *.bss* (Microsoft) or *DATA* (Borland)
- Resources Section, named *.rsrc*
- Export Data Section, named *.edata*
- Import Data Section, named *.idata*
- Debug Information Section, named *.debug*

The names are actually irrelevant as they are ignored by the OS and
are present only for the convenience of the programmer. Means you can find very different names (e.g. packers use their names)

**DOS header + STUB**  
The DOS header occupies the first 64 bytes of the file. It's there in case the program is run from DOS, so DOS can recognise it as a valid executable and run the DOS stub. The DOS stub usually just prints a string like "This program must be run under Microsoft Windows". At the first 2 bytes we have the 'magic signature', `5A4Dh`, or `MZ`. At the end of the DOS header we have a pointer to the PE header, since the DOS STUB doesn't have fixed length.  
![PE Header](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/12-PE-header.png)  

**PE header**  
The first part of the PE header is a signature (like in the DOS header) composed by 4 bytes: `50450000h` ("PE"). After this signature we find the COFF header (20 bytes) and the Optional Header (*not optional for the PE standard, it is needed*) composed by 224 bytes (but it's variable), 96 for the Headers and 128 for the DataDirectory.  
![PE header 2](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/13-PE-header2.png)  

After the section headers we find the sections themselves.  
In the file on disk, each section starts at an offset that is some multiple of the FileAlignment value found in OptionalHeader. Between each section's data there will be `00` byte padding. When loaded into RAM, the sections always start on a page boundary so that the first byte of each section corresponds to a memory page. On x86 CPUs pages are 4kB aligned, whilst on IA-64, they are 8kB aligned. This alignment value is stored in SectionAlignment also in OptionalHeader.  

**Imports**  
Functions used by a program that are stored in a different program, such as library. Connected to the main EXE by linking.  
Can be linked three ways:
- Statically
    - Rarely used for Windows executables
    - More common in Unix/Linux
    - All code from the library is copied into the executable
    - Makes executable large in size
    - The main way to go if you want to have self-contained code
- Dynamically
    - Most common method
    - Host OSs search for necessary libraries when the program is loaded
- At Runtime
    - Unpopular in friendly programs
    - Common in malware, especially packed or obfuscated malware
    - But also used by software that allows dynamic loading of plugins
    - Connect to libraries only when needed, not when the program starts
    - Most commonly done with the *LoadLibrary* and *GetProcAddress* functions

The PE header lists every library and function that will be loaded. Their names can reveal what the program does e.g. "URLDownloadToFile" indicates that the program downloads something.  

**Common DLLs**:  
- `Kernel32.dll`: This is a very common DLL that contains core functionality, such as access and manipulation of memory, files and hardware.
- `Advapi32.dll`: This DLL provides access to advance core Windows components such as Service Manager and Registry.
- `User32.dll`: This DLL contains all the user-interface components, such as buttons, scroll bars and components for controlling and responding to user actions.
- `Gdi32.dll`: This DLL contains functions for displaying and manipulating graphics.
- `Ntdll.dll`: This LL is the interface to the Windows kernel. Executables generally do not import this file directly, although it is always imported indirectly by Kernel32.dll. If an executable imports this file, it means that the author intended to use functionalities not normally available to Windows programs. Some tasks, such as hiding functionality or manipulating processes, will use this interface.
- `WSock32.dll` and `Ws2_32.dll`: These are networking DLLs. A program that accesses either of these most likely connects to a network or performs network-related tasks.
- `Wininet.dll`: This DLL contains higher-level networking functions that implement protocols such as FTP, HTTP and NTP.

Basic Static Analysis of some samples using PE-Studio.

## Lesson 10 - Basic Dynamic Analysis

Running malware deliberately, while monitoring the results. Requires a safe environment, must prevent malware from spreading to production machines. Real machines can be airgapped (no network connection to the Internet or to other machines).  
Static analysis can reach a dead-end, due to Obfuscation, Packing and Examiner has exhausted the available static analysis techniques. Dynamic analysis will show you exactly what the malware does (not really...). Main goal: understand the malware behavior. Approaches: diffing, monitoring, tracing, debugging.  

**Diffing**  
- Take a snapshot of a clean system state and a snapshot of a compromised system state
- Compare before and after
- Pros: Artifacts can be observed easily
- Cons: Can miss evidence that is created during malware activities and erased purposely by malware
- Tools: regshot, autoruns

**System Monitoring**  
- From a clean system state, record every individual change on system and network traffic that appear after execution of the suspicious file.  
- Pro: Can collect all manifested changes  
- Cons: Often too much information and need to weed out irrelevant data  
- Tools: procmon, Wireshark  

**API Tracing**  
- Hook and record important API calls made by the suspicious process
- Pro: Provides visibility into activity beyond the typical file/process/registry/network shown by other tools. Gets you a little closer to the type of interpretation that is required when doing static analysis.
- Cons: Often too much of information and need to weed out irrelevant data. API-specific interpretation can take a lot of time (but still less than static analysis)
- Tools: WinApiOverride, Rohitab API Monitor

**Debugging**  
- Set breakpoints inside the suspicious file to stop its execution at a given location and inspect its state.
- Pro: Provides a superset of the functionality of an API monitor
- Cons: Typically must be be done in conjunction with some basic static analysis and assembly reading. Malware will often change its behavior or refuse to run when being debugged, which requires a work-around.
- Tools: IDA Pro Debugger, OllyDbg, Immunity Debugger, WinDbg

Given the 4 elements we listed above in this order, if you want to have more powerful analysis you should go at the bottom of the list (but they are the most complex ones), instead if you want ease of use you should go at the top of the list (but they are less powerful).  
Limits you need to be aware of (about dynamic analysis):
- in general, single path (execution trace) is examined
- analysis environment possibly not invisible
- analysis environment possibly not comprehensive
- scalability issues
- How do you technically perform it?
    - instrument program, operating system, or hardware

**Program instrumentation**  
- analysis operates in same address space as sample
- manual analysis with debugger
- Detours (Windows API hooking mechanism)
- Binary under analysis is modified
    - breakpoints are inserted
    - functions are rewritten
    - debug registers are used
- Not invisible, malware can detect analysis
- May require significant manual effort

**OS instrumentation**  
- analysis operates in OS where sample is run
- Windows system call hooks
- invisible to (user-mode) malware
- can cause problems when malware runs in OS kernel
- limited visibility of activity inside program
    - cannot set function breakpoints

**HW instrumentation**  
- provide virtual hardware (processor) where sample can execute (sometimes including OS)
- software emulation of executed instructions
- analysis observes activity “from the outside”
- completely transparent to sample (and guest OS)
- operating system environment needs to be provided
- limited environment could be detected, but faster
- complete environment is comprehensive, but slower
- Sandboxes

What do we want to observe? Process interacts with operating system via system calls.
- needs OS for every interaction with environment (file system, network, registry, ...)
- monitor system calls
    - unfortunately, on Windows, system calls largely undocumented and can change without notice
    - developers are supposed to use Windows API, which denotes a collection of stable, user-mode, shared libraries
    - of course, Windows API can be bypassed

Report from the analysis: File activity (read, write, create, open, ...), Registry activity, Service activity, Start/Stop of Windows services (via Service Manager), Process activity (start, terminate process, inter-process communication), Network activity, API calls and packet logs.  
A Sandbox is an All-in-one software for basic dynamic analysis.
- Virtualized environment that simulates network services
    - Examples: Norman Sandbox, GFI Sandbox, Anubis, Joe Sandbox, ThreatExpert, BitBlaze, Comodo Instant Malware Analysis
- They are expensive but easy to use
    - Some of them offer a free tier!
- They can automate dynamic analysis
- They produce a nice PDF report of results (Example from Joe Sandbox Cloud)

A nice by-product of using sandboxes is family classification. Naming conventions derived from Computer Antivirus Research Organization (CARO) Malware Naming Scheme. Example: `Worm:Win32/Taterf.K!dll`. Take into account that Classification schemes are hardly coherent.  
Using real machines there are disadvantages: No Internet connection, so parts of the malware may not work; Can be difficult to remove malware, so re-imaging the machine will be necessary. And there are advantages: Some malware detects virtual machines and won't run properly in one.  
So, Virtual machine is the most common method.
- This protects the host machine from the malware
    - VM-escape attacks are theoretically possible
    - I don’t know about real malware implementing it
    - "naif" VM usage is way more dangerous
- You can easily “snapshot” the VM and revert back to a clean state at the end of each analysis job.

When configuring a VM, You can disable networking by disconnecting the virtual network adapter while the VM is running (but this could break the normal execution of the malware) or Host-only networking allows network traffic to the host but not the Internet. More complex setup are possible!  
Use snapshots to:
- Protect a clean installation of the analysis environment
- Keep track of ongoing progresses during analysis
- Hop instantly from job to job if you need to analyze several samples at the same time.

**Process monitor**  
- Monitors registry, file system, network, process, and thread activity
- All recorded events are kept, but you can filter the display to make it easier to find items of interest
- Don't run it too long or it will fill up all RAM and crash the machine

**Persistence**  
Techniques to survive after reboot
- Registry Key
- File System
-  Startup locations
- DLL search order hijacking
- Trojanizing system les
- Master Boot Record (MBR)
- Basic Input/Output System (BIOS)

**The Registry**  
Repository for configuration and control of Windows systems.
- Systemwide
    - Which device drivers to load, how to con gure memory manager, process manager, etc.
    - Applications read systemwide settings
- Per-user settings
    - Per-user preferences
    - Most-recently accessed documents

Registry key is a container consisting of other keys (subkeys) or values.
| Root Key | Stored Information | Link | 
| ------ | ---------- | ----- | 
| HKEY_CLASSES_ROOT (HKCR) | File association and Component Object Model (COM) object registration (e.g ProgID and CLSID) | Merged | 
| HKEY_CURRENT_USER (HKCU) | Data associated with the currently logged-on user | Yes | 
| HKEY_LOCAL_MACHINE (HKLM) | Global settings for the machine | No | 
| HKEY_USERS (HKU) | All the accounts on the machine | No |
| HKEY_CURRENT_CONFIG (HKCC) | Current Hardware profile | Yes | 

Persistence using File System:
- Startup locations
    - For the logged-in user: `%USERPROFILE%\Start Menu\Programs\Startup`
    - For all users: `%ALLUSERSPROFILE%\Start Menu\Programs\Startup`

## Lesson 11 - Models for Threat Intelligence part 2
THE PYRAMID OF PAIN: Types of indicators
- Hash Values: SHA1, MD5 or other similar hashes that correspond to specific suspicious or malicious les. Often used to provide unique references to specific samples of malware or to files involved in an intrusion.
- IP Addresses: IP address or netblocks referring to the attacker.
- Domain Names: this could be either a domain name itself (e.g. "evil.net") or maybe even a sub- or sub-sub-domain (e.g. "this.is.sooooo.evil.net")
- Network Artifacts: observables caused by adversary activities on your network. In practice this really means those pieces of the activity that might
tend to distinguish malicious activity from that of legitimate users. Typical examples might be URI patterns, C2 information embedded in network protocols, distinctive HTTP User-Agent or SMTP Mailer values, etc..
- Host Artifacts: observables caused by adversary activities on one or more of your hosts. They could be registry keys or values known to be created by specific pieces of malware, files or directories dropped in certain places or using certain names, names or descriptions or malicious services...
- Tools: software used by the adversary to accomplish their mission. Mostly this will be things they bring with them, rather than software or commands that may already be installed on the computer.
- Tactics, Techniques and Procedures (TTPs): how the adversary goes about accomplishing their mission, from reconnaissance all the way through data exfiltration and at every step in between. "Dumping cached authentication credentials and reusing them in Pass-the-Hash attacks" would be a TTP.

THE DIAMOND MODEL  
This model guides the analysis process through several predefined steps that starting from indicators, strive to identify high-level facts about the security incidents that are analyzed
- Describes security *events* (incidents) through few basic aspects
- Connects events that took place in a single intrusion through *activity threads*
- Identifies commonalities among activity threads forming *activity groups* that can then be used for strategic planning

The model represent “events” (intrusion) as a set of core features pertaining to few fundamental aspects.

For every intrusion event there exists an **adversary** taking a step towards an intended goal by using a **capability** over **infrastructure** against a **victim** to produce a result.

An event defines discrete time-bound activity restricted to a specific phase. The adversary may require access to further external resources to fulfill its goal (meta features).  
![diamond model](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/14-diamond-model.png)  
ADVERSARY: actor/organization responsible for utilizing a capability against the victim to achieve their intent.
- Adversary Operator: the actual “hacker” or person(s) conducting the intrusion activity.
- Adversary Customer: the entity that stands to benefit from the activity conducted in the intrusion. It may be the same as the adversary operator, or it may be a separate person or group.

CAPABILITY: tools and/or techniques of the adversary used in the event
- Capability Capacity: all of the vulnerabilities and exposures that can be utilized by the individual capability regardless of victim are considered its capacity.
- Adversary Arsenal: the adversary’s complete set of capabilities, and therefore the combined capacities of their individual capabilities. 
- The C&C typically represent a specific kind of capability used by the adversary.

INFRASTRUCTURE: describes the physical and/or logical communication structures the adversary uses to deliver a capability, maintain control of capabilities and effect results from the victim.
- Directly controlled infrastructure
- Infrastructure controlled by an intermediary
- Public infrastructure providers

VICTIM: target of the adversary and against whom vulnerabilities and exposures are exploited and capabilities used.
- Persona: and individual or organization being targeted
- Asset: the attack surface and consist of the set of networks, systems, hosts, email addresses, IP addresses, social networking accounts, etc. against which
the adversary directs their capabilities.
- The set of vulnerabilities and exposures of a victim susceptible to exploitation is referred to as the victim susceptibilities, they are sub-features of the victim

META FEATURES  
- Timestamp: date and/or time when the event occurred. May include start/end timestamps
- Phase: represents the specific logical role played by the event in an activity thread
    - You may want to stick with the cyber kill chain jargon for phases
- Results: post-conditions of an adversary’s operations
    - Qualitative: <Success,Failure,Unknown>
    - Informative: Con dentiality|Integrity|Availability-compromised
    - Details: refer to the specific compromised assets
- Direction: describes qualitatively the main direction for actions in the event
    - Victim-to-Infrastructure, Infrastructure-to-Victim, Infrastructure-to-Infrastructure, Adversary-to-Infrastructure, Infrastructure-to-Adversary, Bidirectional, or Unknown
- Methodology: description of the general class of activity
    - E.g.: spear-phish email, content-delivery attack, syn flood, etc.
    - Better use an existing taxonomy
- Resources: all supporting elements on which the event, and therefore each core- and meta-feature, depends
    - E.g.: software, knowledge, information, hardware, funds, facilities, access

Two useful feature extensions:
- social-political: describe the relationship existing between the Adversary and its Victims
- technology: Describes the technology connecting and enabling the infrastructure and the capability to operate and communicate.

ANALYTICAL PIVOTING  
Different approaches:
- Victim-centered: analyzing data related to a potential victim reveals the other related (and Diamond-connected) elements: malicious capabilities and infrastructure.
- Capability-centered: exploits features of a capability to discover those other related elements like (i) victims whom that capability is used against, (ii) infrastructure supporting the capability, (iii) technology enabling the capability, (iv) clues to other related capabilities, (v) and (possible) clues to the adversary.
- Infrastructure-centered: focuses on the malicious infrastructure of the adversary. From this element other related elements can be discovered. Difficult access.
- Adversary-centered: mostly reserved to law-enforcement agencies.

ACTIVITY THREAD  
- Vertical correlation
    - Identify knowledge gaps
    - Fill those gaps with new knowledge
    - Establish causal relationships among events
- Horizontal correlation
    - The analytic process of causally linking events between vertical threads across adversary-victim pairs
    - identify common knowledge gaps between threads
    - use knowledge from one thread to fill knowledge gap in another
    - Identify common features across victims which can lead to the creation of an activity group

## Lesson 12 - Basic Dynamic Analysis (Lab)

Exercises using Procmon and flare-Fakenet on two malware samples. 

## Lesson 13 - Advanced Static Analysis Part 1

See the slides for this part since they are mainly composed by images.  
This lesson is about recognizing the software (malware) behaviour by looking at the assembly code (variables, conditions, loops, Windows API calls, handlers, Registry keys, library functions...).

## Lesson 14 - Threat Intelligence example & Yara rules

For the threat intelligence example see the slides since they are mainly composed by images.  

**Yara rules**  
What is YARA?
- Think of it of a sort of "grep" on steroids
    - Useful to quickly check if a new observable matches some known suspicious characteristics
    - Useful to search for a new bit of information in a large dataset
- Much more
    - Help you keep an organized library of matching rules for different threats based on observed IoCs
- What is not
    - An antivirus
    - An host based IDS

The good point is that it is at the same time easy to use, but flexible and extremely powerful.  
It is an executable you can download/compile for your OS (See https://virustotal.github.io/yara/).  
At a minimum, a rule must have a name, and a condition. The simplest possible rule is: `rule dummy { condition: false }`.  
That rule does nothing. Inversely, this rule matches on anything: `rule dummy { condition: true }`.  
Here’s a slightly more useful example that will match on any file over 500 KB: `rule over_500kb {condition: filesize > 500KB}`.  
Standard structure for Yara rules:
```Yara
rule silent_banker : banker
{
    meta:
        description = "This is just an example"
        threat_level = 3
        in_the_wild = true

    strings:
        $a = {6A 40 68 00 30 00 00 6A 14 8D 91}
        $b = {8D 4D B0 2B C1 83 C0 27 99 6A 4E 59 F7 F9}
        $c = "UVODFRYSIHLNWPEJXQZAKCBGMT"

    condition:
        $a or $b or $c
}
```
- Meta section: consists of a set of arbitrary key-value pairs
    - Can be used to describe the rule, and/or the type of content that it matches.
    - Meta values can be strings, integers, decimals, or booleans.
    - The meta values can be viewed by the application that is using YARA when a match occurs.
- Strings section: defines variables as content to be matched.
    - Hexadecimal byte patterns (in {}, with support for wildcards and jumps). Often used to identify unique code, such as an unpacking mechanism
    - Text strings
    - Regular expressions (between //)
- Conditions section: define matching conditions. A few examples:

| Condition | Meaning |
| ------ | ------ |
| `any of them` | The rule will match on anything containing any of the strings defined in the rule. |
| `all of them` | The rule will only match if all of the defined strings are in the content. |
| `3 of them` | The rule will match anything containing at least three of the defined strings. |
| `$a and 3 of ($s*)` | Match content that contains string $a and at least three strings whose variable begins with $s. |

Another example:
```Yara
rule pdf_1.7_contains_few_links {

meta:
    author = "Sean Whalen"
    last_updated = "2017-06-08"
    tlp = "white"
    category = "malicious"
    confidence = "medium"
    killchain_phase = "exploit"
    description = "A PDFv1.7 that contains one or two links - a common phishing tactic"

strings:
    $pdf_magic = {25 50 44 46}
    $s_anchor_tag = "<a " ascii wide nocase
    $s_uri = /\(http.+\)/ ascii wide nocase

condition:
    $pdf_magic at 0 and (#s_anchor_tag == 1 or (#s_uri > 0 and #s_uri < 3))
}
```
Several modules can be imported (PE interpreter example):
```Yara
import "PE"

rule suspicious_pe {
    Strings:
        $str = "procmon"
    Condition:
        pe.imports( "kernel32.dll", "CreateProcess" ) and
        pe.imports( "wininet.dll", "HttpSendRequest" ) and
        $str
}
```
You can reference other rules:
```Yara
rule RULE_EVILMD5 {
    meta:
        description: "Suspicious MD5 Hash"
    condition:
        md5 matches /^3bb34a700e8d21acfdfe0f09208a7c01$/
}
rule RULE_EVILPATH {
    meta:
        description: "Suspicious File Path"
    condition:
        path contains "/appdata/roaming"
}
rule RULE_SUSP_BHV {
    meta:
        description = "Suspicious behaviour"
    condition:
        RULE_EVILMD5 and RULE_EVILPATH
}
```
Identify PE files:
```Yara
rule is_PE_file {
    strings:
        $mz = "MZ"
        $pe = "PE"
    condition:
        ($mz at 0) and
        ($pe at (uint32(0x3c)))
}
```
You can find more advanced examples on the slides (Assembly rule based detection)

## Lesson 15 - Advanced Static Analysis (Lab)

Exercise using PEStudio and IDA disassembler with an executable file (Bomb).

## Lesson 16 - Advanced Dynamic Analysis

- Basic dynamic analysis focuses on externally observable behavior
- Advanced static analysis focuses on malware internals
- Both can fall short for different reasons
    - malware evasion (e.g., detection of analysis tools and virtual machines)
    - trigger-based behavior (e.g., wait for a packet containing a command)
    - code obfuscation and packing
    - anti-disassembly, self-modifying code

**Debugging**  
- A debugger enables the analysis of execution in different ways
    - instruction-level
    - registers and memory contents
    - function calls
    - threads and exceptions
- Ability to inspect and control execution provides critical insights
- A debugger can be used also to alter the execution...

- Two ways to a debugging session
    - load a program from the debugger
    - attach to a running process
- Desirable features
    - Inspect and alter registers (including EIP)
    - Inspect and alter memory and its layout
    - Capture control flow transfers and specific instructions
    - Control threads (e.g. pause and resume them)
    - Modify code being executed

- A debugger can follow one thread at a time
- Stepping lets you execute instructions in a controlled way
    - Single stepping steps through the instructions one at a time, exactly as how the CPU sees them arriving. To be used selectively, i.e. on narrow portions.
- Function calls and returns as milestones in the execution
    - Stepping into a call instruction means that the debugger will perform single-stepping over the instructions of the called function
    - Stepping over a call instruction means that single-stepping mode will be resumed only when the called function returns (if it ever does...)
    - When stepping out of a function, the debugger suspends single-step execution and will resume it only once execution leaves the function

**Breakpoints**  
Breakpoints let the program run until a point of interest is reached  
- Instruction breakpoints pause execution once EIP reaches the address of interest
- Memory breakpoints are more general and trap accesses to arbitrary memory addresses
    - on read/write access
    - on write access only
    - on execute (like an instruction breakpoint)
- Conditional breakpoints suspend execution only when an additional condition is matched (e.g. stop at address 0x401130 only when ECX=8)

- Instruction breakpoints can be implemented via software or using hardware assistance
- A software breakpoint replaces the rst byte of the instruction at the given address with INT 3 (opcode 0xCC)
    - CPU generates a software interrupt and the debugger captures the event
    - Analysts can insert as many software breakpoints as they want
    - However, they are conspicuous: malware may look for them!
        - performing a checksum of its .text section
        - or just looking for 0xCC in its code

A hardware breakpoint does not alter code, but leverages the CPU debug registers to trap execution automatically.  
- Conditional breakpoints evaluate one user-provided condition before entering single-stepping mode
    - Very useful on loops (e.g. break only after N iterations)
    - Useful also for function calls (e.g. condition on some argument)
    - Careful: they slow down execution also when they don’t cause single-stepping
- Memory breakpoints can be software or hardware based
    - Hardware: up to 4 bytes (dword size) per registered breakpoint
    - Software: not 100% reliable as they change memory protection attributes
    - Very useful when dealing with e.g. packed malware

**Exceptions**  
Exceptions are a CPU mechanism for implementing alternative control flow, e.g. to handle virtual memory or recover from errors. From the CPU’s perspective they are an interrupt (just like the INT instruction). Debuggers use them to regain control of the execution (Instruction/memory breakpoints, Single-stepping when trap ag TF in EFLAGS is set). To handle an exception, a corresponding handler must have been registered: Benign programs use them to handle error situations (like division by zero), Malware analysts use them to hinder analysis (for instance if the debugger catches an exception meant for the malware, it can give away its presence).  
A debugger can catch an exception up to two times: Exceptions are passed to the debugger as they occur. However, first-chance exceptions can be passed to the program when they are unrelated to debugging (e.g. floating point or division-by-zero error), When the program cannot recover from the exception (e.g. there is no corresponding registered handler), the debugger receives it again. Second-chance exceptions requires intervention or the program will crash. Malware often uses exceptions as an anti-debug technique.  

ASLR can be nuisance when debugging (addresses change!)
- For programs compiled with `/DYNAMICBASE` Windows randomizes the base address for *.text* at every execution. Thus the addresses that you see in the code (e.g. in IDA) may not match what you see in a debugger.
- IDA offers manual loading for a PE and a rebase option for the current session (Edit->Segments->Rebase Program)
- Alternatively, you can modify the PE header using CFF Explorer (OptionalHeader->Dll Characteristics->DLL can move) but might not always work in Windows 10

Many debuggers available around. Some are particularly well suited for malware analysis and reverse engineering: WinDbg, IDA Pro, IDA Freeware, OllyDbg 1.1 & 2.0, Immunity Debugger, x64dbg, radare2...  
Learn shortcuts to use IDA more efficiently!  
- `Escape`: go back to previous position in current view
- `Ctrl+Enter`: go forward to next position in current view
- `Space`: switch between text and graph mode
- `G`: jump to address in current view
- `F2`:
    - (during static code analysis) set a breakpoint at the current instruction
    - (during debugging) enable edit mode to change selected value, then F2 again to apply changes
- `X`: show cross referencing info for selected function entrypoint
- `N`: rename selected reference
- https://www.hex-rays.com/products/ida/support/freefiles/IDA_Pro_Shortcuts.pdf (some commands are available in Pro version only)

Brief explanation of IDA debugger.


## Lesson 17 - Cyber Threat Intelligence Sharing

- The practice of sharing cyber threat intelligence, vulnerabilities, configurations, best practices, knowledge and tips to a larger external community.
- Goal: To enhance the cyber security of an individual organization as well as that of the entire sharing community.
- Enterprises/Organizations: obtain a vast stream of cyber security information that can be highly tailored to their infrastructure, network/host systems, software etc...
- Community: the pooled intelligence, knowledge and experience allows for a much more effective cyber defense.

Be aware of some Legislative requirements (e.g. NIS Directive).  
![NIS Directive](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/15-nis-directive.png)  

**Sharing models**

**Centralized/Hub & Spoke/Subscriber** (Requires wide-scale trust)  
- Data enhancement, added analysis
- Macro trend analysis
- Rule/agreement enforcement, organization
- Anonymization/data cleansing
- Low technical costs for new consumers

**Direct/Peer-to-Peer**  
- Tailored for efficiency and speed
- Lower trust requirements
- Often requires participants to have more sophisticated and matured cyber threat sharing operations
- Hard to scale; better suited for ad-hoc sharing
    - Mature cyber threat sharing organizations are highly inclined to personalized, private partnerships; especially when in the same industrial domains.

![Sharing tech](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/16-sharing-tech.png)

**Explanation of STIX (Structured Threat Information Expression)**  
For this part refer to the appropriate slides since this part is full of images.  

## Lesson 18 - Advanced Dynamic Analysis (Lab)  
Played with DudeLocker.exe from Flare On challenge by Fireeye (https://www.fireeye.com/content/dam/fireeye-www/global/en/blog/threat-research/flareon2016/challenge2-solution.pdf)


## Lesson 19 - Code Packing 
A technique to hide the original code of a program through one or more layers of compression and/or encryption. Malware writers use it to make static analysis harder, hide from certain anti-virus products via polimorphism. Useful to shrink benevolent programs (or protect them if combined with obfuscation): therefore, packing tools cannot be banned! In-depth analysis of packed malware starts in a debugger: put in other words, we must "unpack" the sample...  

- Windows loader loads programs to memory as follows:
    - reads the PE header on disk
    - allocates memory for each section declared in PE header
    - transfers contents of sections from file on disk to memory
    - applies relocations when needed
    - solves imports
    - jumps to program's entry point
- For packed programs, the Windows loader loads their unpacking stub, which eventually loads the program in a custom fashion

In the unpacking terminology, the entry point of the original application is known as the original entry point (OEP). The unpacking stub is the entry point of the packed program. Eventually, it jumps to OEP.
![oep](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/17-oep.png)  

- Packing can be nested (multi-layer)
- Sophisticated packers have evolved into executable protectors
    - anti-debugging
    - anti-sandbox/VM
    - anti-tampering
    - anti-disassembly
- Compressing packers vs encrypting packers
    - Compressed programs may retain statistical properties
    - Encrypted programs have larger entropy (which is an indicator of packing, but not necessarily of malicious behavior)

- Unpacking stub is the only code exposed to the analyst. Therefore, static analysis of a packed sample says little about the payload!
- Unpacking stub performs three steps
    1. Unpack original executable into memory
    2. Resolve all the imports of the original executable
    3. Transfer execution to OEP

The unpacking stub reconstructs on the fly both the import table and the PE header (which will slightly differ from the original one).  
![oep 2](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/18-oep2.png)  
- PE header includes
    - a section to tell the loader which functions it should import from DLLs
    - a section to store the addresses of imported (by name/ordinal) functions
- As the Windows loader is unaware of the imports from the packed program, the unpacking stub has to fill the Import Address Table
- IAT operates as lookup table. 4 strategies when unpacking:
    - LoadLibrary + GetProcAddress to manually solve each import
    - keep the original IAT intact
    - keep one imported function per DLL used in the original IAT
    - remove all imports, nd LoadLibrary and GetProcAddress elsewhere

**IAT Resolution - Strategy 1**  
Use LoadLibrary and GetProcAddress to solve each import. This is the simplest and most common strategy. Main steps:  
1. after unpacking, read the original INT (Import Name Table)
2. load each required DLL using LoadLibrary
3. within each DLL, solve imported functions using GetProcAddress
4. patch the original IAT with the address of each resolved function


![INT](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/19-int.png)  
Credits: https://blogs.jpcert.or.jp/en/2017/01/anti-analysis-t-24b9.html  

```
// simplified sketch (solves by name)
PIMAGE_NT_HEADERS ntheaders = <get PE ntheaders from unpacked base>
PIMAGE_DATA_DIRECTORY impDir = &(ntHeaders->
OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT]);
PIMAGE_IMPORT_DESCRIPTOR impDesc = base + impDir->VirtualAddress;
DWORD idx = -1;
while (pImpDesc[++idx].Characteristics) {
    LPCSTR dll = base + impDesc[idx].Name;
    PIMAGE_THUNK_DATA pINT = base + impDesc[idx].OriginalFirstThunk;
    PIMAGE_THUNK_DATA pIAT = base + impDesc[idx].FirstThunk;
    PIMAGE_IMPORT_BY_NAME pName = base + pInt->u1.AddressOfData;
    pIAT->u1.Function = GetProcAddress(LoadLibraryA(dll), pName);
}
```

**IAT Resolution - Strategy 2**  
- Keep the original INT intact
    - unpacking stub no longer solves imports: the Windows loader did!
    - lacks stealth: static analysis reveals all original imports
    - amenable to fingerprinting by import hashing (with known limitations)

**IAT Resolution - Strategy 3**  
- Keep one imported function for each DLL in original IAT/INT
    - static analysis sees only one function per library
    - will still reveal what DLLs are imported
    - unpacking stub slightly simpler than in strategy 1 (no LoadLibrary activity)
    - functions will be solved manually with GetProcAddress

**IAT Resolution - Strategy 4**  
- Remove all imports, nd LoadLibrary and GetProcAddress elsewhere
    - stealth: the packer includes no imports
    - manually locate LoadLibrary and GetProcAddress in memory
        - look for kernel32.dll in memory and parse its export table (we will see later in the course that shellcode works similarly)
    - or manually look for them among imports of other modules
        - parse the export table of each module and locate the offsets of the wanted functions
    - (slightly) increased level of complexity in unpacking stub
    - loading many libraries at run-time can trigger an alert from AV products

**The Tail Jump**  
- Once the stub ends its work, it must transfer execution to OEP
- This transfer is normally referred to as tail jump
- Simple packers jump into unpacked code only once
- More complex packers may transfer pieces of the unpacking stub to a new region and continue unpacking from there
- A jmp instruction is the most common (but also obvious) way
    - Packers can use call or push the address to stack and then use ret
    - OS control transfer functions like NtContinue or ZwContinue can be used too

**Some simple indicators (of packed code)**  
- Few imports, with LoadLibrary and GetProcAddress typically present
- Small amount of code recognized by disassembler
- Program shows characteristic memory section names (e.g., UPX0)
- Abnormal section sizes (e.g., raw data size is 0 while virtual size is > 0)
- Entropy calculation for compressed/encrypted data

None of the indicators above should be trusted individually (it may even be a decoy). When multiple indicators are met, the sample is likely packed.

**Approaches to unpacking**  
Automatic solutions may save your day. Or waste your time...  
- Automatic static unpackers work for specific packers such as UPX, operating as an extractor for a known packing algorithm
- Automatic dynamic unpackers run the executable and try to intercept when the unpacking stub ends (and where original code is located). Suitable for one-shot packers, not very reliable
- Manual unpacking is the only way in many cases, or the most reliable one. Sometimes can be done quickly, sometimes is painful.  

**Static unpacking**  
- If you think of a packer as of a compression/encryption algorithm, you need individual plugins
- Typically only simple packers are supported
- Famous tools include PE Explorer (commercial), Universal Extractor (free), and lately Quick Unpack.

**Automatic dynamic unpacking**  
- PinDemonium (BlackHat USA 2016)
    - Monitor write ranges
    - Look for a behavioral pattern: for instance, violation of W⊕X policy (DEP = Write xor eXecute)
    - Heuristic: dump previously written-to region every time EIP jumps into it
- BinUnpack (CCS 2018)
    - Memory access monitoring is tedious
    - Intercepts API invoked through a rebuilt IAT
    - Intuition: unpacking is likely over by then

**Manual unpacking**  
Two approaches are possible:  
- Figure out the unpacking algorithm and implement it yourself
    - i.e., you would be writing an automatic static unpacker
    - may take a significant amount of time
- Let the unpacking stub do the work, then dump the memory
    - if you do it right, you only have to fix the PE header for the dump
    - trial-and-error process

**Debugger plugins**  
- Debugger plugins can aid manual unpacking
    - Scylla comes with dumping capabilities
    - For a better control you may check OllyDumpEx (multi-debugger)
- Section Hop (trace-over) approach with debugger scripting
    - Trace intructions and memory accesses to determine when EIP moves across different mapped memory sections
    - Instruction tracing is slow. Also, beware that multiple hops are possible
    - OEP detection: target of hop is a good candidate
    - Reveals simple packers like UPX

**Manual OEP identification**  
- Section Hop is like step-over debugging for memory
    - Function calls in programs may often cross regions (think of library code), so stepping over call instructions when looking for OEP might rule out many false positives among OEP candidates
    - However, packers can use calls that do not return to foil this approach, so that
OEP is not found. One has then to try stepping into (some) calls…
- Section Hop may be ineffective on some packers
    - Looking for a tail jump is a better strategy!

Tips for locating a tail jump:  
- Last instruction valid before a bunch of garbage bytes
- Target of jump contains garbage bytes
- Look for jump targets that are many bytes away from current address
- Jumps normally encode control flow (e.g., if-else, loop) within a single function
- However, compiler optimizations may jump into functions for performance (tail call)
- Breakpoints
    - memory breakpoint on the stack entry touched by the first push operation in the unpacking stub
    - identify loops and follow them
    - track accesses to GetProcAddress (if the packer is fixing the IAT, execution is far into the unpacking stub but there is some work left before the tail jump)
    - track accesses to common functions used at the start of unpacked programs (e.g., GetVersion, GetCommandLine, GetModuleHandle), then go backwards

**Rebuilding IAT and PE header**  
- Likely fixes required for a dump
    - Entry point in PE header should point to newly found OEP
    - PE file needs to contain the right metadata (e.g., Import Name Table) so that the Windows Loader can build the IAT like the unpacking stub did
- Tools can help in the PE dump fixing process

- Import Reconstructor tool (ImpREC)
    - Takes RVA of OEP: meaning, relative virtual address of the original entry point (the offset!) from the base address used for unpacking process
    - Example: if OEP is at *0x452323* in dump and image base for the program is the default *0x400000*, then the RVA of OEP is *0x52323*
    - IAT Autosearch will locate the IAT reconstructed at run time
    - GetImports extracts data from the table (check for valid:YES)
    - FixDump applies changes to a copy the dumped binary

- Scylla  
    - Addresses known limitations of ImpREC and other prior tools
    - Like ImpREC, it can attach to a running process (also: similar GUI features)
    - A precompiled version of Scylla ships with x64dbg

IAT reconstruction is essentially a hacking activity  
- Invalid entries sometimes can just be removed. Or have to be xed?
- A dumped binary with an invalid IAT will most likely crash
- Loader uses two tables: packers may delete the INT table with function names once their addresses have been solved and written to the other table!
- When automatic IAT reconstruction fails, an analyst can manually look up function call sites and solved addresses in the unpacked code, take notes and attempt IAT reconstruction manually

- Don’t be misled: **packing and obfuscation are orthogonal**  
    - Packers eventually reveal the original code
    - Obfuscators don't: they alter the original code (you don’t get to see it...)
    - Packing and obfuscation techniques are often used together (executable protectors are very popular among malware authors)
- Unpacking is a one-shot process only in simple packers
    - Multiple layers of packing can be used
    - Shifting-decode-frame packers reveals only one code page at a time

## Lesson 20 - Code Packing (Lab)

Analysis of some packed malware samples using PEStudio, IDA disassembler, x32dbg and Scylla.

## Lesson 21 - Code Injection

- Packing hides code from static analysis
- Covert launching techniques hide code from dynamic analysis
    - set up execution so as to conceal malicious behavior to user/analyst
    - usually involves a third component: one victim process
    - a sample that loads its code somewhere else is a launcher
- Goals for the analyst
    - figure out the target of the launcher
    - analyze the payload being deployed

- Covert launching often means injecting code in another process
- Vast universe of techniques
    - process hollowing
    - DLL injection
    - PE injection
    - thread execution h acking
    - reflective DLL injection
    - hook injection
    - APC injection
    - ...

**Process hollowing**  
- Process hollowing disguises malware as a legitimate process and is robust against crashes
- Idea: start a process in a suspended state, then replace its code
    - when you load a process as suspended, only an external action can start it
    - before that action, the launcher will:
        - deallocate currently mapped sections of the process
        - allocate memory to accommodate for the malicious payload
        - write the payload contents to the address space of the victim
        - update the context of the suspended main thread (EIP <= entry point for payload)
    - finally, resume suspended main thread

![process hollowing](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/20-proc-hollowing.png)  
C pseudocode for process hollowing
```C
CreateProcess(..., "svchost.exe", ..., CREATE_SUSPEND,...);
ZwUnmapViewOfSection(...);
VirtualAllocEx(..., ImageBase, SizeOfImage, ...);
WriteProcessMemory(..., headers, ...);
for (i=0; i < NumberOfSections; i++) {
    WriteProcessMemory(..., section, ...);
}
SetThreadContext();
...
ResumeThread();
```
VirtualAllocEx, allocates memory within a foreign process. We need to use a suitable address for the base image of the payload... (if default addresses don’t match, the launcher must apply relocations).  
Process hollowing works best with position-independent code.

**DLL Injection**  
- DLL injection creates a *remote thread* in a victim process to make it load an attacker-chosen DLL
    - Pros: can get around restrictions for processes (e.g. firewall)
    - Cons: conspicuous, requires the DLL file to be on disk
- Idea: remote thread that invokes LoadLibrary
    - obtain a handle to suitable victim process (e.g., CreateToolhelp32Snapshot -> Process32First -> Process32Next)
    - allocate memory for the string containing the DLL path and write to it
    - get the address of LoadLibrary and use it as entry point of remote thread
        - kernel32.dll APIs (its functions will appear in both processes at the same addresses) => GetModuleHandle/LoadLibrary for "kernel32.dll", then GetProcAddress for "LoadLibraryA"
C Pseudocode for DLL Injection
```C
hVictimProcess = OpenProcess(PROCESS_ALL_ACCESS, 0, victimProcessID);

pNameInVictimProcess = VirtualAllocEx(hVictimProcess, ..., sizeof(maliciousLibraryName), ...);
WriteProcessMemory(hVictimProcess, ..., maliciousLibraryName, sizeof(maliciousLibraryName), ...);
GetModuleHandle("Kernel32.dll");
GetProcAddress(..., "LoadLibraryA");
CreateRemoteThread(hVictimProcess, ..., LoadLibraryAddress, pNameInVictimProcess, ...);
```
DLL injection may be detected easily when debugging
- DLL name/path sometimes materialized just before calling WriteProcessMemory for it
- Address of LoadLibraryA can be solved anytime (even before OpenProcess)
- Memory allocation, write operations, and thread creation must go in this exact order
- Once you know the path, you can load and analyze the DLL in IDA

**PE Injection**  
- PE injection writes new code alongside the one of the victim process
    - Same machinery of DLL injection, but stealthier: no file on disk
- Requires careful code crafting to avoid breaking the host
    - unpredictable availability of a base address
    - unless you are injecting simple shellcode, special care is required for storage (e.g. strings), imported functions, and relocation
- Technical details
    - multiple write operations (e.g., one for code, one for data, etc.)
    - loops to x relocation right before calling CreateRemoteThread
    - before the thread starts, you can dump the contents of write operations (or write down their addresses for a full dump) to analyze them separately  
![PE Injection](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/21-PE-Injection.png)   

**Thread Execution Handling**  
- Also known as suspend, inject & resume
- Idea: instead of creating a remote thread, h ack a running one
    - look for a suitable thread in a process with CreateToolhelp32Snapshot -> Thread32First -> Thread32Next -> OpenThread
    - suspend its execution with SuspendThread
        - this method can crash a running application
        - hint: check whether EIP is within the range of ntdll.dll (for a system call not returned yet)
    - use VirtualAllocEx and WriteProcessMemory to allocate memory for injection (could be a DLL path for LoadLibrary, a shellcode, or even a whole PE)
    - modify EIP of target thread using SetThreadContext
    - start it using ResumeThread

An example of generic trojan using it 
- *GetThreadContext* takes a lpContext to store the current thread CONTEXT
- the sample alters EIP in the CONTEXT to point to LoadLibrary's entrypoint, just retrieved from the image of kernel32.dll
- it also updates CONTEXT for reading from stack the DLL path to load
- *SetThreadContext* + *ResumeThread*

Credits: https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process
Sample: `787cbc8a6d1bc58ea169e51e1ad029a637f22560660cc129ab8a099a745bd50e`   

**Reflective DLL Injection**  
- A weakness of DLL injection is the DLL presence on disk. Also, security products keep an eye on DLLs...
- Unfortunately, Windows doesn’t have a "LoadLibrary" that can read the contents of a DLL directly from memory
- Idea: mimic what the Windows loader does
    - compile your payload as a DLL (with a DllMain function)
    - DLL must contain an exported function that acts as ReflectiveLoader

- Launcher
    - allocate enough memory in victim and copy the DLL into the bu er
    - get RVA of ReflectiveLoader within DLL and combine with bu er’s base
    - create a remote thread in the victim to run ReflectiveLoader
- ReflectiveLoader
    - locate PEB (e.g. `mov eax, fs:[0x30]`)
    - parse it to locate kernel32.dll and other libraries
    - parse exports of kernel32.dll to locate LoadLibrary, GetProcAddress, VirtualAlloc, and other relevant functions needed to x IAT; apply relocations
    - execute DllMain as entry point (DLL_PROCESS_ATTACH parameter)

PoC: https://github.com/stephenfewer/ReflectiveDLLInjection

**Hook Injection**  
- Windows offers the possibility to register hooks to intercept messages destined for the current process or for a remote one
    - Remote hooks used for keylogging, but also to load a DLL 🧐
    - Depending on the event type, special privileges may be needed
- Two types of remote hooks
    - High-level: use a DLL export as hook procedure
    - Low-level: use a function that runs in the process that installed the hook
- *SetWindowsHookEx* is the key API

See: https://resources.infosecinstitute.com/topic/using-setwindowshookex-for-dll-injection-on-windows/

- *SetWindowsHookEx* takes 4 arguments
    - idHook: type of hook procedure to install. Hook types include keyboard strokes WH_KEYBOARD\[\_LL] and mouse movements WH_MOUSE\[\_LL], but also less popular/conspicuous events
    - lpfn: address of the hooking function
    - hMod: handle to module containing the function (DLL for high-level hooks)
    - dwThreadId: thread ID to associate the hook procedure with; zero implies that all threads get monitored (the only option for low-level hooks).
- We target a specific thread using a high-level hook
    - monitoring all threads is suspicious, necessary only for a keylogger


- *CreateToolhelp32Snapshot* and *Thread32Next* to locate a specific thread
- *SetWindowsHookExA* returns a handle: a sample can wait for it to be triggered (*WaitForSingleObject*) and then remove the hook (*UnhookWindowsHookEx*)
- The victim executes the malicious code when the DLL gets injected in it!

Credits: https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process  
Sample (Taken from Locky ransomware): `5d6ddb8458ee5ab99f3e7d9a21490ff4e5bc9808e18b9e20b6dc2c5b27927ba1`  

**APC Injection**  
- In Windows, an Asynchronous Procedure Call (APC) is a mechanism to temporarily divert the execution of a thread
- Each thread has an APC queue that the system polls periodically
    - When the thread is in an alertable state (or even when it hasn’t started yet)
    - A thread enters an alertable state when executing
        - WaitForSingleObjectEx
        - WaitForMultipleObjectsEx
        - MsgWaitForMultipleObjectsEx
        - SleepEx
        - SignalObjectAndWait

Example:  
- *QueueUserAPC*
    - pfnAPC is the user-supplied function to be called by the thread
    - hThread is the handle to the thread of interest
    - dwData is a single (pointer) value that is passed to the pfnAPC function

**AtomBombing**  
- AtomBombing uses Atom Tables (meant to share strings between applications) to perform stealthy memory writes into a victim process
- It forces the victim process to activate the code written in Atom Tables using the *NtQueueApcThread* syscall
    - *QueueUserApc* is not suitable as it takes only 1 pointer value, while to invoke function *GlobalGetAtomName* we need 3. However, *QueueUserApc* internally
relies on *NtQueueApcThread*, which takes exactly 3 parameters 🤪
    - written code is not executable: use a ROP chain to get around DEP
- AtomBombing is an elegant injection vector, as it exploits design vulnerabilites to appear legitimate

Technique: https://blog.ensilo.com/atombombing-brand-new-code-injection-for-windows  
PoC: https://github.com/BreakingMalwareResearch/atom-bombing  

**Phantom DLL Hollowing**  
- Transactional NTFS (TxF) is a Windows feature to use the filesystem in a DBMS-like mode with transient changes as part of a transaction
- Phantom DLL hollowing opens a TxF handle on a legit Windows DLL, changes its code, and forces a process to load the modified DLL
- Put in other words, it achieves hollowing of a DLL without altering any memory permissions and the updated file contents stay invisible
- *NtCreateSection* with SEC_IMAGE + *NtMapViewOfSection*
- Recently revamped (by Sapienza folks 🙃) to beat Code Integrity Guard

Technique: https://www.forrest-orr.net/post/malicious-memory-artifacts-part-i-dll-hollowing  
PoC: https://github.com/forrest-orr/phantom-dll-hollower-poc  

**Injecting for other purposes**  
- Malware authors have used code injection not only for covert launching, but also to steal data from a running process
- Ursnif (Gozi-ISFB) steals banking and online account credentials by injecting a component tailored to a specific browser
- To avoid detection, Ursnif can create child processes and alter their TLS callbacks to inject a DLL into them before they start

PoC from leaked ISFB code: https://github.com/gbrindisi/malware/blob/master/windows/gozi-isfb/AcDll/activdll.c  
Write-up on the reversing of a more recent strain of ISFB: https://www.vkremez.com/2018/08/lets-learn-in-depth-reversing-of-recent.html  

- 64-bit Windows adds a twist to the injection game
    - WoW64 compatibility layer lets 32-bit programs run on 64-bit Windows
    - 32-bit code can call *IsWow64Process()*
- Try to inject 32-bit code in a 64-bit program and you get a crash
    - Victim process has to be chosen carefully
    - Beware of WoW64: for instance, *svchost.exe* is available in *%SystemRoot%\System32\* but you get a 32-bit version in *%SystemRoot%\SysWOW64\*
- What about 64-bit code with a 32-bit launcher?
    - Ideally a 32-bit loader may carry 32-bit and 64-bit payloads and decide which one to use depending on the victim machine
- Injecting in a 64-bit host from a 32-bit loader: can it be done?
    - Even if you get the addresses right, you cannot create a remote thread…
    - However, if you force your CPU to enter 64-bit mode, you can!
- CPU will interpret instructions as 32 or 64-bit depending on the code segment selector (0x23 vs. 0x33 value)
    - WoW64 uses this mechanism to make system calls (since the Windows kernel runs 64-bit code). Can you do the same?
    - Yes! Heaven’s Gate let us abuse 64-bit processes from a 32-bit loader by entering 64-bit mode for carrying injection-related API calls!
    - If you know what you’re doing, you can even achieve cross-architecture reflective DLL injection by putting all the pieces together 🙂

**References**  
- https://disman.tl/2015/03/16/cross-architecture-reflective-dll-inection.html
- https://www.endgame.com/blog/technical-blog/ten-process-injection-techniques-technical-survey-common-and-trending-process
- https://www.endgame.com/blog/technical-blog/hunting-memory
- https://www.blackhat.com/docs/asia-17/materials/asia-17-KA-What-Malware-Authors-Don't-Want-You-To-Know-Evasive-Hollow-Process-Injection-wp.pdf
- https://blog.kwiatkowski.fr/?q=en/process_hollowing
- https://arvanaghi.com/blog/dll-injection-using-loadlibrary-in-C/
- https://resources.infosecinstitute.com/code-injection-techniques/
- https://www.usenix.org/conference/woot19/presentation/pavithran
- https://www.vmray.com/cyber-security-blog/atombombing-evasion-and-detection/
- https://securityintelligence.com/dridexs-cold-war-enter-atombombing/
- https://cloudblogs.microsoft.com/microsoftsecure/2017/07/12/detecting-stealthier-cross-process-injection-techniques-with-windows-defender-atp-process-hollowing-and-atom-bombing/
- https://blog.malwarebytes.com/threat-analysis/2018/01/a-coin-miner-with-a-heavens-gate/
- http://www.alex-ionescu.com/?p=300
- https://github.com/dadas190/Heavens-Gate-2.0
- https://www.malwaretech.com/2014/02/the-0x33-segment-selector-heavens-gate.html
- http://waleedassar.blogspot.com/2013/01/wow64logdll.html
- https://www.blackhat.com/us-21/briefings/schedule/#rope-bypassing-behavioral-detection-of-malware-with-distributed-rop-driven-execution-23051
- https://stackover ow.com/questions/8776437/c-injecting-32-bit-targets-from-64-bit-process
- http://www.corsix.org/content/dll-injection-and-wow64
- https://stackover ow.com/questions/13297452/
- http://www.rohitab.com/discuss/topic/42310-injecting-code-from-64-bit-process/
- https://github.com/rwfpl/rewolf-wow64ext
- https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All.pdf & associated code https://github.com/SafeBreach-Labs/pinjectra
- https://www.usenix.org/system/ les/woot19-paper_pavithran.pdf
- https://tyranidslair.blogspot.com/2019/08/windows-code-injection-bypassing-cig.html
- https://github.com/hasherezade/pe-sieve

