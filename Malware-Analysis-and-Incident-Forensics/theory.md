# Malware Analysis and Incident Forensics - Theory

## Lesson 1 - Introduction

General news about malware-based attacks:
- [Yahoo 'state' hackers stole data from 500 million users](https://www.bbc.com/news/world-us-canada-37447016)
- [Brian Krebs site hit with 665 Gbps DDoS attack; Largest Internet has ever seen](https://www.hackread.com/brian-krebs-website-665-gbps-ddos-attack/)
- [The Equifax data breach exposes extremely
sensitive data from 143 million consumers](https://www.bloomberg.com/news/articles/2017-09-07/equifax-says-cyber-intrusion-affected-143-million-customers)

The data breach market is ourishing. Black markets provide advanced tools for data search. Prices are extremely variable depending on the specific product.

The topic of this course revolves around *Cyber Security*:  
“preservation of confidentiality, integrity and availability of information in the Cyberspace” (ISO-27000)  
Cyberspace is “the complex environment resulting from the interaction of people, software and services on the Internet by means of technology devices and networks connected to it, which does not exist in any physical form” (NIST)

The role of malware  
![malware types](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/01-malware-types.jpg)  
Source: https://www.gdatasoftware.com/blog/2018/09/31037-malware-figures-first-half-2018-danger-web

The **Attack Killchain** is a list made of 8 points explaining the anatomy of a malware:  
- Reconnaissance
- Weaponization
- Delivery
- Exploitation
- Persistence
- Callback
- Data exfiltration
- Lateral spread

In this course we will go deep in the last 4 points.

Expected behaviours:
- Persistence
    - The malware installs itself in the system
    - It performs actions to guarantee its survivability to reboots, inspections, etc.
    - Often modifies the OS configuration
    - Changes are hidden
- Uniqueness
    - Malware is often incompatible with itself
    - Multiple concurrent executions are meaningless
      - Or sometimes dangerous for the malware itself
      - Think about two ransomware instances competing for the same resources
    - Checks at startup guarantee te execution of a single copy
- Obfuscation and evasion
    - Malware will try to hide its presence and its effects to stay undetected as long as possible
    - It may inject code in the processes to conceal its real identity
    - It may mangle its internal code to hide easily discoverable hints of its malicious nature
    - It may leverage techniques to hamper the possibility to correctly analyze its behavior
- Fingerprinting
    - Malware will inspect the infected system and collect information about it
    - Information can be used to “publicize” its presence to a remote server
    - Sometimes the malware may locally use this information to control its own behavior
        - e.g. fully deploy its payload only in a specific country, or at a specific date
- Communication
    - Malware often interact with external command & control services to
        - receive instructions and commands
        - update its internal components
        - exfiltrate data
    - Communication may use an impressively heterogeneous set of links
    - Data on channels is often obfuscated

## Lesson 2 - The Attack Killchain part 1

The 5 Ws of a CyberAttack:

| W | Answer |
|-----------------|--------------|
| Who | Targets: Single users, Industries, Financial, Health, Energy, IT, Manufacture, Public agencies, MIL & Defense.  Threats: Hackers, Activists, Undercover operations, Industrial espionage, Cyberterrorists, Cyberwarfare.  Other actors: Research (academia, agencies, individuals), Security firms and experts, White-hat hackers, CERTs and government agencies, MIL & Defense. |
| What | Activities of interest: Data theft, Machine control, Financial fraud, Disruption of operation, Defacing, Physical damage. |
| Why | Motivations: Financial gain, Politics/ Hacktivism, Doxing, Terrorism / Cyberwarfare, Revenge |
| Where and When  | https://cybermap.kaspersky.com |

The evolution of Malware:
- 1998 CIH (https://en.wikipedia.org/wiki/CIH_(computer_virus))
- 2001 Code Red (https://en.wikipedia.org/wiki/Code_Red_(computer_worm))
- 2003 Slammer (https://en.wikipedia.org/wiki/SQL_Slammer)
- 2004 MyDoom (https://en.wikipedia.org/wiki/Mydoom)
- 2005 PoisonIvy (https://en.wikipedia.org/wiki/PoisonIvy_(trojan))
- 2007 Zeus (https://en.wikipedia.org/wiki/Zeus_(malware))
- 2008 Agent.btz (https://en.wikipedia.org/wiki/Agent.BTZ)
- 2010 Stuxnet (https://en.wikipedia.org/wiki/Stuxnet)
- 2010 DigiNotar (https://en.wikipedia.org/wiki/DigiNotar)
- 2012 Flame (https://en.wikipedia.org/wiki/Flame_(malware))
- 2017 Wannacry (https://en.wikipedia.org/wiki/WannaCry_ransomware_attack)
- 2017 Petya (https://en.wikipedia.org/wiki/Petya_(malware))
- A growing trend (http://www.informationisbeautiful.net/visualizations/worlds-biggest-data-breaches-hacks/)

The production chain of malware:
1. Malware coder writes malicious software to exploit a computer vulnerability and install a trojan.
2. Victim infected with credential-stealing malware.
3. Banking credentials siphoned.
4. Hacker retrieves banking credentials.
5. Remote access to compromised computers.
6. Hacker logs into victim's online bank account
7. Money transferred to mule.
8. Money transferred from mule to organizers.

Read also the [Verizon 2021 Data breach investigations report](https://www.verizon.com/business/resources/reports/dbir/2021/).

## Lesson 3 - x86 Assembly language (Lab)

We will focus on Windows malware, the most dominant OS by far.  
We could see some malware written in Powershell or even Python, but in most cases the malware samples are written in binary code.  
Binary code is a coding system using the binary digits 0 and 1 to represent a letter, digit, or other character in a computer or other electronic device.  
Obviously is the most low level code we could have and we are interested in reverse engineering it.  
Decompilers (e.g., Ghidra, Hex-Rays, rev.ng, Snowman) try to reconstruct a high-level C-like representation of binary code. Process far from perfect:
- information loss during compilation (e.g., types)
- for an obfuscated code you get an obfuscated source...
- anti-analysis techniques

Nonetheless, decompilers are useful when reverse engineering.  

In CPUs there are registers that have the purpose of storing tiny portions of information useful to be retrieved in a very fast way by the processor.  
Instruction Set Architecture (ISA) = abstract model that describes what a programmer should know to program a machine
**ISA** ≈ interface between software and hardware. Humans/compilers produce ISA-conformant assembly code, then an assembler encodes it in a binary format understood by hardware.  
- Intel defined the x86 ISA for its 8086 processor
- 1976-1978. Additions and extensions preserved backward compatibility
- Also known as IA-32. Today most malware is still 32-bit
- x86-64 (x64 for short) is the 64-bit successor

A word is the natural data unit for a specific CPU design. For x86 processors, the word size is 32 bits.  
However, for backward compatibility, x86 instructions assume a word operand to be 16-bit long, while a dword operand is 32-bit long.  
IA32 common data types: byte, word, dword.  
Memory always operates at byte level. Endianness specifies how multi-byte sequences are read from/written to memory.  
![endianness](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/02-endianness.png)

Registers are memory units CPU uses for fast retrieval of data.  
Coders use (many) variables. CPUs work on (few) registers. x86 general-purpose registers are 32-bit wide.  
Registers hold data with fast access time:
- General-purpose registers (GPRs) can store data or memory addresses
- Status register holds truth values on the state of the processor from past computations (used e.g. for conditional computations)
- Program counter holds the address of the instruction being executed
- Many other registers

![accessing registers](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/03-accessing-registers.png)  
Credits: Yale's CS421

Program counter EIP (Instruction Pointer) and status register EFLAGS cannot be accessed directly.  

This is the instruction cycle (Fetch-decode-execute cycle):  
- *Fetch*: CPU reads instruction from address stored in EIP
- *Decode*: control unit determines meaning of the instruction
- *Execute*: carry out computation using ALU or move data
- Then EIP advances to the next adjacent instruction, unless current instruction explicitly altered the control flow (e.g., with a jump)
Instructions have variable size (1-15 bytes) and are stored in memory consecutively, along with any immediate operands (data or addresses) they might use. Register operands are captured instead by the opcode binary representation:
~~~
b8 01 00 00 00      mov eax, 0x1
bf 01 00 00 00      mov edi, 0x1
~~~

Addressing modes provide a way to express the addresses of data to be read from/written to the main memory.  
Expressions can take immediate operands, registers, or both.  
Addressing modes enable operand combinations to compute complex expressions that depend on the program state.  
Usually, an instruction can have at most one memory operand (no memory-to-memory operations allowed).

Some popular ways to specify data to be read from/written to the main memory. For the last two rows the offset field is optional:
| Mode | Intel syntax |
| ---- | ---- |
| Immediate | `mov eax, [0x1000]` |
| Register | `mov eax, [esi]` |
| Register + offset | `mov eax, [esp-8]` |
| Register * width + offset | `mov eax, [ebx*4+0xff]` |
| Base + Register * width + offset | `mov eax, [edx+ebx*4+8]` |

![Intel memory map of a process](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/04-memory-map-process.png)

There are some security mechanisms to prevent weird and dangerous things to damage the memory and the host. 
- Paging mechanisms
    - determine whether an address is valid
    - enforce read/write/execute permissions on regions
    - pages in kernel space are accessible from kernel code only
- Operating systems may enforce high-level security mechanisms to hinder memory vulnerability exploitation attacks
    - DEP (Data Execution Prevention)
    - ASLR (Address Space Layout Randomization)
    - Heap allocation randomization & other protections in Windows 10

**Basic x86 instructions**
Programs are written using three kinds of instructions:  
- Data movement
- Arithmetic & logic
- Program flow control

*Data movement instructions* are straightforward
- `mov dest, src` Copy {register, memory content, immediate} to {register, memory location}
- `push src` Used for stack manipulation
- `pop dest` Used for stack manipulation

*Arithmetic instructions* are relevant for code analysis for many reasons:
- computing oﬀsets and function addresses
- stack pointer modifications
- used like data movement ones or to update EFLAGS

- `add dest, src`: dest += src
- `sub dest, src`: dest -= src
- `inc dest`: ++dest
- `dec dest`: --dest
- `not dest`: 1's complement
- `neg dest`: 2's complement

Then we have *logic instructions*, some common instances:  
- zero-ing registers: xor eax, eax
- extracting bits and checking conditions
- obfuscation

Beware that these operations are bit-wise. High-level logical operations such as && and || have a diﬀerent semantic.  
- `and dest, src`: bitwise AND
- `or dest,src`: bitwise OR
- `xor dest, src`: bitwise XOR

We have also *rotate/shift instructions* (when src is absent, a default of 1 is assumed):
- `shr dest, src` and `shl dest, src`: Unsigned shift (right/left)
- `sar dest, src` and `sal dest, src`: Signed shift (right/left)
- `ror dest, src` and `rol dest, src`: Rotate (right/left)
- `rcr dest, src` and `rcl dest, src`: Rotate with carry (right/left)

Finally we have *program control flow instructions*:
- Control flow can be implemented in three ways
    - *Unconditional branch*: EIP is overwritten with some desired address
    - *Conditional branch*: EIP is overwritten with some desired address depending on the value of one or more bits from EFLAGS
    - *Function calls and returns*: special kind of unconditional branches
- Two ingredients needed
    - a means to specify the target of a branch (static or dynamic)
    - a means to evaluate a condition on the program state
- Code locations in assembly can be annotated with labels

An *unconditional branch* can take as destination:
- an oﬀset, specified as a relative oﬀset from the current EIP value or as an absolute oﬀset (from the base of the current code segment...)
- or an absolute address, provided as a register or memory operand
![Unconditional branch](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/05-unconditional-branch.png)

*Conditional branches* evaluate conditions over selected bits of the EFLAGS register. Common cases:  
- CF (carry flag), meant for errors in unsigned arithmetics
- OF (overflow flag), meant for errors in signed arithmetics
- SF (sign flag), set when the result of an operation is negative
- ZF (zero flag), set when the result of an operation is zero

To compare two values we can use the cmp instruction. `cmp dest, src` computes the diﬀerence dest-src without modifying dest, and sets the flags above in a way that allows for many useful comparisons...  
A *Jcc* instruction checks the condition specified by *cc* suﬃx and jumps to the given oﬀset (no absolute addresses) accordingly  
Say we just executed `cmp D, S`:
|  | Jump to L if | Negated version |
| ---- | ---- | ---- |
| `je L`; `jz l` | D==S | [D!=S] `jne L`; `jnz L` |
| `jg L`; `jnle l` | D>S | [D<=S] `jng L`; `jle L` |
| `jge L`; `jnl l` | D>=S | [D<S] `jnge L`; `jl L` |
| `ja L`; `jnbe l` | > with unsigned operands | `jna L`; `jbe L` |
| `jae L`; `jnb l` | >= with unsigned operands | `jnae L`; `jb L` |

Another instruction commonly used in comparisons is *test*, it computes the bitwise AND of its operands without altering them.  
Let's say we want to check whether register D holds zero as value, `test D, D` will set the zero flag iﬀ. D==0, then *jz* can be used.  
Beware that malware won’t use only *cmp* and *test* (e.g. you can decrement a value with *dec* or *sub* and then check if the instruction set the zero flag with *jz* (also optimizing compilers do that!).  

**Function** is a unit of code that controls register values and its portion of stack independently of other units.  
- if a code unit calls another, the latter should not clobber registers in use
- a CPU comes with few general-purpose registers: one may want to spill (i.e., save) some values on the stack and fetch them later in the execution

The stack is conceptually divided into frames, one per currently active function. A frame usually includes:
- the arguments for the function invocation
- local function variables and other storage
- return address for the call (i.e., where to resume execution upon function exit)

Suppose we do not have free registers left, and we would like to add to EDX the diﬀerence between EBX and ECX:
![Local storage](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/06-local-storage.png)

`push src` moves the top of the stack up by 4 bytes, then copies the content of the operand (immediate or register) to the address pointed by the updated ESP.  
`pop dest` copies the 4 bytes currently pointed by ESP to the dest register, then moves the top of the stack down by 4 bytes.  
push/pop operations can also be realized via sub/add + mov:  
~~~
push ebp
xor ecx, ecx
pop edx
~~~
Can be written as:
~~~
sub esp, 4
mov [esp], ebp
xor ecx, ecx
mov edx, [esp]
add esp, 4
~~~

When entering a function that makes use of local variables, register EBP can be used to reference their locations via fixed oﬀsets.
![Base pointer](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/07-base-pointer.png)

**Lab activity**: Introduction to IDA disassembler, analysis of some basic compiled binaries from C code.

# Lesson 4 - x86 Assembly language part 2 (Lab)

A function is a unit of code that controls register values and its portion of stack independently of other units.  
- if a code unit calls another, the latter should not clobber registers in use
- a CPU comes with few general-purpose registers: one may want to spill (i.e., save) some values on the stack and fetch them later in the execution

The stack is conceptually divided into frames, one per currently active function. A frame usually includes:
- the arguments for the function invocation
- local function variables and other storage
- return address for the call (i.e., where to resume execution upon function exit)
