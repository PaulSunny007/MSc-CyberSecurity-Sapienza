# Malware Analysis and Incident Forensics - Theory

## Lesson 1 - Introduction

General news about malware-based attacks:
- [Yahoo 'state' hackers stole data from 500 million users](https://www.bbc.com/news/world-us-canada-37447016)
- [Brian Krebs site hit with 665 Gbps DDoS attack; Largest Internet has ever seen](https://www.hackread.com/brian-krebs-website-665-gbps-ddos-attack/)
- [The Equifax data breach exposes extremely
sensitive data from 143 million consumers](https://www.bloomberg.com/news/articles/2017-09-07/equifax-says-cyber-intrusion-affected-143-million-customers)

The data breach market is ourishing. Black markets provide advanced tools for data search. Prices are extremely variable depending on the specific product.

The topic of this course revolves around *Cyber Security*:  
“preservation of confidentiality, integrity and availability of information in the Cyberspace” (ISO-27000)  
Cyberspace is “the complex environment resulting from the interaction of people, software and services on the Internet by means of technology devices and networks connected to it, which does not exist in any physical form” (NIST)

The role of malware  
![malware types](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/01-malware-types.jpg)  
Source: https://www.gdatasoftware.com/blog/2018/09/31037-malware-figures-first-half-2018-danger-web

The **Attack Killchain** is a list made of 8 points explaining the anatomy of a malware:  
- Reconnaissance
- Weaponization
- Delivery
- Exploitation
- Persistence
- Callback
- Data exfiltration
- Lateral spread

In this course we will go deep in the last 4 points.

Expected behaviours:
- Persistence
    - The malware installs itself in the system
    - It performs actions to guarantee its survivability to reboots, inspections, etc.
    - Often modifies the OS configuration
    - Changes are hidden
- Uniqueness
    - Malware is often incompatible with itself
    - Multiple concurrent executions are meaningless
      - Or sometimes dangerous for the malware itself
      - Think about two ransomware instances competing for the same resources
    - Checks at startup guarantee te execution of a single copy
- Obfuscation and evasion
    - Malware will try to hide its presence and its effects to stay undetected as long as possible
    - It may inject code in the processes to conceal its real identity
    - It may mangle its internal code to hide easily discoverable hints of its malicious nature
    - It may leverage techniques to hamper the possibility to correctly analyze its behavior
- Fingerprinting
    - Malware will inspect the infected system and collect information about it
    - Information can be used to “publicize” its presence to a remote server
    - Sometimes the malware may locally use this information to control its own behavior
        - e.g. fully deploy its payload only in a specific country, or at a specific date
- Communication
    - Malware often interact with external command & control services to
        - receive instructions and commands
        - update its internal components
        - exfiltrate data
    - Communication may use an impressively heterogeneous set of links
    - Data on channels is often obfuscated

## Lesson 2 - The Attack Killchain part 1

The 5 Ws of a CyberAttack:

| W | Answer |
|-----------------|--------------|
| Who | Targets: Single users, Industries, Financial, Health, Energy, IT, Manufacture, Public agencies, MIL & Defense.  Threats: Hackers, Activists, Undercover operations, Industrial espionage, Cyberterrorists, Cyberwarfare.  Other actors: Research (academia, agencies, individuals), Security firms and experts, White-hat hackers, CERTs and government agencies, MIL & Defense. |
| What | Activities of interest: Data theft, Machine control, Financial fraud, Disruption of operation, Defacing, Physical damage. |
| Why | Motivations: Financial gain, Politics/ Hacktivism, Doxing, Terrorism / Cyberwarfare, Revenge |
| Where and When  | https://cybermap.kaspersky.com |

The evolution of Malware:
- 1998 CIH (https://en.wikipedia.org/wiki/CIH_(computer_virus))
- 2001 Code Red (https://en.wikipedia.org/wiki/Code_Red_(computer_worm))
- 2003 Slammer (https://en.wikipedia.org/wiki/SQL_Slammer)
- 2004 MyDoom (https://en.wikipedia.org/wiki/Mydoom)
- 2005 PoisonIvy (https://en.wikipedia.org/wiki/PoisonIvy_(trojan))
- 2007 Zeus (https://en.wikipedia.org/wiki/Zeus_(malware))
- 2008 Agent.btz (https://en.wikipedia.org/wiki/Agent.BTZ)
- 2010 Stuxnet (https://en.wikipedia.org/wiki/Stuxnet)
- 2010 DigiNotar (https://en.wikipedia.org/wiki/DigiNotar)
- 2012 Flame (https://en.wikipedia.org/wiki/Flame_(malware))
- 2017 Wannacry (https://en.wikipedia.org/wiki/WannaCry_ransomware_attack)
- 2017 Petya (https://en.wikipedia.org/wiki/Petya_(malware))
- A growing trend (http://www.informationisbeautiful.net/visualizations/worlds-biggest-data-breaches-hacks/)

The production chain of malware:
1. Malware coder writes malicious software to exploit a computer vulnerability and install a trojan.
2. Victim infected with credential-stealing malware.
3. Banking credentials siphoned.
4. Hacker retrieves banking credentials.
5. Remote access to compromised computers.
6. Hacker logs into victim's online bank account
7. Money transferred to mule.
8. Money transferred from mule to organizers.

Read also the [Verizon 2021 Data breach investigations report](https://www.verizon.com/business/resources/reports/dbir/2021/).

## Lesson 3 - x86 Assembly language (Lab)

We will focus on Windows malware, the most dominant OS by far.  
We could see some malware written in Powershell or even Python, but in most cases the malware samples are written in binary code.  
Binary code is a coding system using the binary digits 0 and 1 to represent a letter, digit, or other character in a computer or other electronic device.  
Obviously is the most low level code we could have and we are interested in reverse engineering it.  
Decompilers (e.g., Ghidra, Hex-Rays, rev.ng, Snowman) try to reconstruct a high-level C-like representation of binary code. Process far from perfect:
- information loss during compilation (e.g., types)
- for an obfuscated code you get an obfuscated source...
- anti-analysis techniques

Nonetheless, decompilers are useful when reverse engineering.  

In CPUs there are registers that have the purpose of storing tiny portions of information useful to be retrieved in a very fast way by the processor.  
Instruction Set Architecture (ISA) = abstract model that describes what a programmer should know to program a machine
**ISA** ≈ interface between software and hardware. Humans/compilers produce ISA-conformant assembly code, then an assembler encodes it in a binary format understood by hardware.  
- Intel defined the x86 ISA for its 8086 processor
- 1976-1978. Additions and extensions preserved backward compatibility
- Also known as IA-32. Today most malware is still 32-bit
- x86-64 (x64 for short) is the 64-bit successor

A word is the natural data unit for a specific CPU design. For x86 processors, the word size is 32 bits.  
However, for backward compatibility, x86 instructions assume a word operand to be 16-bit long, while a dword operand is 32-bit long.  
IA32 common data types: byte, word, dword.  
Memory always operates at byte level. Endianness specifies how multi-byte sequences are read from/written to memory.  
![endianness](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/02-endianness.png)

Registers are memory units CPU uses for fast retrieval of data.  
Coders use (many) variables. CPUs work on (few) registers. x86 general-purpose registers are 32-bit wide.  
Registers hold data with fast access time:
- General-purpose registers (GPRs) can store data or memory addresses
- Status register holds truth values on the state of the processor from past computations (used e.g. for conditional computations)
- Program counter holds the address of the instruction being executed
- Many other registers

![accessing registers](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/03-accessing-registers.png)  
Credits: Yale's CS421

Program counter EIP (Instruction Pointer) and status register EFLAGS cannot be accessed directly.  

This is the instruction cycle (Fetch-decode-execute cycle):  
- *Fetch*: CPU reads instruction from address stored in EIP
- *Decode*: control unit determines meaning of the instruction
- *Execute*: carry out computation using ALU or move data
- Then EIP advances to the next adjacent instruction, unless current instruction explicitly altered the control flow (e.g., with a jump)
Instructions have variable size (1-15 bytes) and are stored in memory consecutively, along with any immediate operands (data or addresses) they might use. Register operands are captured instead by the opcode binary representation:
~~~
b8 01 00 00 00      mov eax, 0x1
bf 01 00 00 00      mov edi, 0x1
~~~

Addressing modes provide a way to express the addresses of data to be read from/written to the main memory.  
Expressions can take immediate operands, registers, or both.  
Addressing modes enable operand combinations to compute complex expressions that depend on the program state.  
Usually, an instruction can have at most one memory operand (no memory-to-memory operations allowed).

Some popular ways to specify data to be read from/written to the main memory. For the last two rows the offset field is optional:
| Mode | Intel syntax |
| ---- | ---- |
| Immediate | `mov eax, [0x1000]` |
| Register | `mov eax, [esi]` |
| Register + offset | `mov eax, [esp-8]` |
| Register * width + offset | `mov eax, [ebx*4+0xff]` |
| Base + Register * width + offset | `mov eax, [edx+ebx*4+8]` |

![Intel memory map of a process](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/04-memory-map-process.png)

There are some security mechanisms to prevent weird and dangerous things to damage the memory and the host. 
- Paging mechanisms
    - determine whether an address is valid
    - enforce read/write/execute permissions on regions
    - pages in kernel space are accessible from kernel code only
- Operating systems may enforce high-level security mechanisms to hinder memory vulnerability exploitation attacks
    - DEP (Data Execution Prevention)
    - ASLR (Address Space Layout Randomization)
    - Heap allocation randomization & other protections in Windows 10

**Basic x86 instructions**
Programs are written using three kinds of instructions:  
- Data movement
- Arithmetic & logic
- Program flow control

*Data movement instructions* are straightforward
- `mov dest, src` Copy {register, memory content, immediate} to {register, memory location}
- `push src` Used for stack manipulation
- `pop dest` Used for stack manipulation

*Arithmetic instructions* are relevant for code analysis for many reasons:
- computing oﬀsets and function addresses
- stack pointer modifications
- used like data movement ones or to update EFLAGS

- `add dest, src`: dest += src
- `sub dest, src`: dest -= src
- `inc dest`: ++dest
- `dec dest`: --dest
- `not dest`: 1's complement
- `neg dest`: 2's complement

Then we have *logic instructions*, some common instances:  
- zero-ing registers: xor eax, eax
- extracting bits and checking conditions
- obfuscation

Beware that these operations are bit-wise. High-level logical operations such as && and || have a diﬀerent semantic.  
- `and dest, src`: bitwise AND
- `or dest,src`: bitwise OR
- `xor dest, src`: bitwise XOR

We have also *rotate/shift instructions* (when src is absent, a default of 1 is assumed):
- `shr dest, src` and `shl dest, src`: Unsigned shift (right/left)
- `sar dest, src` and `sal dest, src`: Signed shift (right/left)
- `ror dest, src` and `rol dest, src`: Rotate (right/left)
- `rcr dest, src` and `rcl dest, src`: Rotate with carry (right/left)

Finally we have *program control flow instructions*:
- Control flow can be implemented in three ways
    - *Unconditional branch*: EIP is overwritten with some desired address
    - *Conditional branch*: EIP is overwritten with some desired address depending on the value of one or more bits from EFLAGS
    - *Function calls and returns*: special kind of unconditional branches
- Two ingredients needed
    - a means to specify the target of a branch (static or dynamic)
    - a means to evaluate a condition on the program state
- Code locations in assembly can be annotated with labels

An *unconditional branch* can take as destination:
- an oﬀset, specified as a relative oﬀset from the current EIP value or as an absolute oﬀset (from the base of the current code segment...)
- or an absolute address, provided as a register or memory operand
![Unconditional branch](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/05-unconditional-branch.png)

*Conditional branches* evaluate conditions over selected bits of the EFLAGS register. Common cases:  
- CF (carry flag), meant for errors in unsigned arithmetics
- OF (overflow flag), meant for errors in signed arithmetics
- SF (sign flag), set when the result of an operation is negative
- ZF (zero flag), set when the result of an operation is zero

To compare two values we can use the cmp instruction. `cmp dest, src` computes the diﬀerence dest-src without modifying dest, and sets the flags above in a way that allows for many useful comparisons...  
A *Jcc* instruction checks the condition specified by *cc* suﬃx and jumps to the given oﬀset (no absolute addresses) accordingly  
Say we just executed `cmp D, S`:
|  | Jump to L if | Negated version |
| ---- | ---- | ---- |
| `je L`; `jz l` | D==S | [D!=S] `jne L`; `jnz L` |
| `jg L`; `jnle l` | D>S | [D<=S] `jng L`; `jle L` |
| `jge L`; `jnl l` | D>=S | [D<S] `jnge L`; `jl L` |
| `ja L`; `jnbe l` | > with unsigned operands | `jna L`; `jbe L` |
| `jae L`; `jnb l` | >= with unsigned operands | `jnae L`; `jb L` |

Another instruction commonly used in comparisons is *test*, it computes the bitwise AND of its operands without altering them.  
Let's say we want to check whether register D holds zero as value, `test D, D` will set the zero flag iﬀ. D==0, then *jz* can be used.  
Beware that malware won’t use only *cmp* and *test* (e.g. you can decrement a value with *dec* or *sub* and then check if the instruction set the zero flag with *jz* (also optimizing compilers do that!).  

**Function** is a unit of code that controls register values and its portion of stack independently of other units.  
- if a code unit calls another, the latter should not clobber registers in use
- a CPU comes with few general-purpose registers: one may want to spill (i.e., save) some values on the stack and fetch them later in the execution

The stack is conceptually divided into frames, one per currently active function. A frame usually includes:
- the arguments for the function invocation
- local function variables and other storage
- return address for the call (i.e., where to resume execution upon function exit)

Suppose we do not have free registers left, and we would like to add to EDX the diﬀerence between EBX and ECX:
![Local storage](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/06-local-storage.png)

`push src` moves the top of the stack up by 4 bytes, then copies the content of the operand (immediate or register) to the address pointed by the updated ESP.  
`pop dest` copies the 4 bytes currently pointed by ESP to the dest register, then moves the top of the stack down by 4 bytes.  
push/pop operations can also be realized via sub/add + mov:  
~~~
push ebp
xor ecx, ecx
pop edx
~~~
Can be written as:
~~~
sub esp, 4
mov [esp], ebp
xor ecx, ecx
mov edx, [esp]
add esp, 4
~~~

When entering a function that makes use of local variables, register EBP can be used to reference their locations via fixed oﬀsets.
![Base pointer](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/07-base-pointer.png)

**Lab activity**: Introduction to IDA disassembler, analysis of some basic compiled binaries from C code.

# Lesson 4 - x86 Assembly language part 2 (Lab)

A code piece may invoke a function using the call instruction. Unlike jumps, before the control transfer takes place it stores on the stack the address of the instruction that follows it. This address is called the *return address* for the call. The callee can fetch it using `ret` and resume execution in the caller: this instruction will populate EIP with the address read from the top of the stack.  
Functions exists only at a logical level, their code is laid out in memory without special "separators". An adversary may scramble their layout, making it hard to identify function boundaries!  
During a function execution everything can happen, for example the code can modify some registers that should be use later...  
(At least) two questions left:  
- How are register values preserved across function invocations?
- How are parameters being passed to functions?

**Calling conventions** regulate:
- how parameters are passed (via registers/stack) and in which order
- which registers the callee must preserve for the caller
- who performs ESP realignment upon return
- Malware may use custom calling conventions for its functions, but has to follow standard ones to interact with Windows APIs.

**Calling conventions - Windows**
Diﬀerent conventions can be used in the same program  
*cdecl (C programs)*  
- arguments pushed on the stack, right-to-left order
- caller saves EAX, ECX, and EDX when in use (i.e. free for callee, which then has to preserve EBP, EBX, EDI, and ESI whenever it needs to use them)
- caller adjusts ESP after return
- 32-bit return value stored in EAX

*stdcall (Win32 API)*
- arguments, caller/callee-save registers and return value as in cdecl
- callee adjusts stack pointer on return
- ret N instruction is used, where N indicates to add N+4 bytes to ESP after EIP is updated

Example: **CDECL**  
![cdecl](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/08-cdecl.png)

For **STDCALL** is the same, but at the end of *subtract* function we have `ret 8` and we don't have `add esp, 8` after `call subtract`.  

*Caller-save* registers are pushed to the stack before a call, if the caller is going to use their values after the call (typically EAX, ECX, EDX).    
*Callee-save* registers are pushed to the stack in the prologue of the callee when it needs to use them (typically EDI, ESI, EBX).  
Compilers often prefer callee-save registers for performance: when register pressure gets high also caller-save registers are used. But in custom code we can find any sort of assortment...  

When used as base pointer a function prologue may set EBP with:
```
push ebp
mov ebp, esp
```
This can be done with a single instruction: `enter`.

To leave a function ESP must point to the caller’s return address. In the epilogue EBP can come to the rescue:
```
mov esp, ebp
pop ebp
```
This can be done with a single instruction: `leave`.

*LEA* (Load Eﬀective Address) evaluates an expression that defines a memory address and writes it to a destination register
- data movement and ALU instructions dereference a given address and operate on the content of the pointed location
- LEA simply computes an address!

Two uses:
- address calculation (pointer arithmetic)
- arithmetic expressions

Suppose EBX=0x1000, and 0xABADCAFE is stored at 0x1004.
- `mov eax, [ebx+4]` will copy 0xABADCAFE to register EAX.
- `lea eax, [ebx+4]` will copy 0x1004 to register EAX.

Source operands for LEA are not necessarily addresses... Suppose EAX=10, EBX=4 and we have to compute C=A+2\*B-1. `lea ecx, [eax+2*ebx-1]` will do the trick with a single instruction!  
Constraint: width for multiplication has to be 1, 2 or 4.

**REP instructions**  
Special instructions for manipulating bytes in buﬀers
- `cmpsb` to compare bytes from two buﬀers
- `stosb` to initialize all bytes in a buﬀer with same value
- `movsb` to copy one buﬀer into another
- `scasb` to search a byte in a buﬀer

They are preceded by a REP prefix: it repeats the operation until ECX == 0 or an additional condition on ZF is verified. EDI contains the address of the first buﬀer (destination), ESI contains the address of the second buﬀer (source), and AL contains the byte to set/search.  
We can implement the memcmp, memset, memcpy and memchr C functions using just the instructions above.

More hands on. Tests on Windows VM with IDA.

## Lesson 5 - More on the A.K. and the anatomy of an attack

We have the concept that an 'attack' is mainly made by people outside of the target and attacking the system breaching the border defenses and entering into. It's not so true, more and more attacks are changing this concept.  

Most dangerous attacks are today characterized by
- Precise targeting
    - Mass campaigns vs. precise targeting
- Full control of target (RAT)
    -  Remote access + privilege escalation
    - Multi-step attacks and compromisations
    - The attacker aims to fully control targets
- Long-term persistence (APT)
    - Multiple backdoors (Some of them may stay silent to provide backup entrance after target recovery)
    - Activity obfuscation
    - Security measure sidesteps + evasion

The **Intrusion (Attack) Killchain** is always the same:
- Recoinnassaince
- Weaponization
- Delivery
- Exploitation
- Persistence
- Callback
- Data exfiltration
- Lateral spread

**Reconnaissance**
- Definition of the target surface
- The attacker looks for the best strategy to apply
- Target pro ling
    - Through social media
    - Public data sources
    - Doxing attacks
- Widely underrated phase of an attack

**Weaponization**
A theoretical attack (or proof-of-concept) is transformed in running code. We need a feature having either a bug or undesired/non-designed/undocumented functionalities.  
- This is the step that requires strong technical skills
- Often "outsourced"
- Unknown vulnerabilities are extremely valuable
    - 0-day exploits
    - Sold for hundreds of $ on black markets
    - Valuable as long as they remain secret

**Delivery**
The exploit is delivered through a vector (Email 93%, Web 6%, other 1%).
- phishing
- spear phishing
- watering hole

Technologies:
- EXE
- DOC, XLS, etc.
- PDF
- Javascript
- ZIP
- Flash
- Other

**Exploitation**
Attack methods:
- 0-day exploit
- known software vulnerability
- misconfiguration
- bad user behavior

**Persistence** (and Installation)
- Payload download
- Payload must be obfuscated while it trespasses boundary security
    - Secure channels
    - Code obfuscation and polymorphism
    - Encryption
    - Steganography
    - Use your imagination (tweets, Facebook messages, etc.)

Example: downloader.BMP.exe uses steganography to encrypt commands in a BMP file header.

Example: TROJAN.MSIL.BERBOMTHUM.AA
- uses steganography to hide commands in JPG images 
- pictures are distributed through social accounts (Twitter)

**Callback**
- After installation the payload cleans up what remains of the infiltration procedure
- It may leverage local exploit to escalate local privileges
- Detecting the intrusion from this moment may be extremely di cult
- The payload contact a C&C server to
    - receive further instructions
    - download modules
- The communication is obfuscated as well

**Data exfiltration**
- Any information in a single PC is potentially valuable
    - Passwords
    - private encryption keys
    - Documents
    - Information about the surrounding network
- Once the malware obtained administration privileges it can do whatever you may imagine:
    - install and use further software
    - impersonate you
    - act as a proxy
    - monitor the surrounding environment with your webcam

**Lateral spread**
- Your PC may just be an access point to a larger network
- The attacker will take his time and explore his surrounding to in ltrate further resources
- The attacker is there to stay as long as possible

How much does it take for each step?
- Reconnaissance -> days/months
- Weaponization -> days/months
- Delivery -> minutes/hours
- Exploitation -> milliseconds
- Persistence -> years
- Callback -> years
- Data exfiltration -> years
- Lateral spread -> years

## Lesson 6 - x86 Assembly language part 3 (Lab)

Exercises using IDA disassembler.  

- Recognize stdcall and cdecl calling conventions
- REP instructions
- Self modifying code

## Lesson 7 - Basic Static Analysis - part 1

The goal of Malware Analysis.  
Information required to contain/mitigate a network intrusion
- Understand what exactly happened
- Make sure you’ve located all infected machines and les
- Understand how to measure and contain the damage
- Find indicators of compromise (IoCs)
- Build rules for intrusion detection systems

Dissecting malware to understand (A critical part of incident response!)
- How it works
    - Know your enemy’s strategies
- How to identify it
    - Extract signatures/IoCs (Indicators of compromise)
    - Prevent further similar infections
- How to defeat or eliminate it
    - Rollback (if possible) its e ects
    - Clean the infected system

**Signatures**
- Host-based signatures
    - Identify les/processes/registry keys on a victim computer that indicate an infection
    - Focus on what the malware does to the system, not the malware itself
        - Behavioural analysis. Di erent from antivirus signature!
- Network signatures
    - Detect malware by analysing network tra c
        - Does the malware inspect the surroundings?
        - Does the malware contact an external Command & Control (C&C or C2) server?
    - More effective when coupled with malware analysis

**Stay safe:**
- Keep a safe offline backup of your important data
- Always perform analysis on a virtual machine
- Keep a safe offline backup of your important data
- Disconnect the virtual machine from the network unless netcomms are necessary
- Keep a safe offline backup of your important data
- If you nd references to external IP addresses NEVER EVER try to directly contact them
- and ... keep a safe offline backup of your important data

**Static Analysis**
- Examines malware without running it
- Tools: strings, PE inspection tools, a disassembler like IDA Pro, etc.

**Dynamic Analysis**
- Run the malware and monitor its effects
- Use a virtual machine and take snapshots
- Tools: RegShot, Process Monitor, Process Hacker, CaptureBAT, debuggers,…
- RAM Analysis: Mandant Redline and Volatility


Basic static analysis: View malware without looking at its code. Tools: strings, PE inspection, etc. Quick and easy but fails for advanced malware and can miss important behaviour.  
Basic dynamic analysis: Easy but requires a safe test environment. Not effective on all malwares.  

Advanced static analysis: Reverse-engineering the malware code with a disassembler. Complex, requires understanding of assembly code and how such code interacts with the OS.  
Advanced Dynamic Analysis: Run code in a debugger. Examines internal state of a running malicious executable and how such state evolves.

**Types of malware**
- Backdoor: Allows attacker to control the system
- Botnet: All infected computers receive instructions from the same Command-and-Control (C2) server
- Downloader
    - Malicious code that exists only to download other malicious code
    - Used when attacker first gains access
- Information-stealing malware: Sniffers, keyloggers, password hash grabbers
- Launcher
    - Malicious program used to launch other malicious programs
    - Often uses non-traditional techniques to ensure stealth or greater access to a system
- Rootkit
    - Malware that conceals the existence of other code
    - Designed to deeply hide in the infected machine to evade detection
        - User-level
        - Kernel-level
        - Bootkits
    - Usually paired with a backdoor or other functionalities
- Scareware
    - Frightens user into buying something
    - Ask for Ransom
- Spam-sending malware: Attacker rents machine to spammers
- Worms or viruses: Malicious code that can copy itself and infect additional computers

**Expected behaviors**
- Uniqueness
    - Malware is often incompatible with itself
    - Multiple concurrent executions are meaningless
        - Or sometimes dangerous for the malware itself
        - Think about two ransomware instances competing for the same resources
    - Checks at startup guarantee the execution of a single copy
- Environment checks
    - Malware is designed to work in appropriate environment
    - Checks at startup if speci c execution conditions are met (Time/date, Localization, Availability of specific resources, etc.)
- Persistence
    - The malware installs itself in the system
    - It performs actions to guarantee its survivability to reboots, inspections, etc.
    - Often modifies the OS configuration
    - Changes are hidden
- Obfuscation and evasion
    - Malware will try to hide its presence and its e ects to stay undetected as long as possible
    - It may inject code in other processes to conceal its real identity
    - It may mangle its internal code to hide easily discoverable hints of its malicious nature
    - It may leverage techniques to hamper the possibility to correctly analyse its behaviour
- Fingerprinting
    - Malware will inspect the infected system and collect information about it
    - Information can be used to "publicize" its presence to a remote server
- Communication
    - Malware often interacts with external command & control services to
        - receive instructions and commands
        - update its internal components
        - exfiltrate data
    - Communication may use heterogeneous links types
    - Data on channels is often obfuscated

You don’t need to understand 100% of the code. Focus on key features, try Several tools and if one tool fails, try another one. Don’t get stuck on a hard issue, move along. Malware authors are constantly raising the bar.  

**Basic Static Analysis**
Techniques: Antivirus scanning, hashes, a file's strings, functions and headers.  
Malware can easily change its signature and fool the antivirus. [VirusTotal](https://www.virustotal.com/gui/home) is convenient, but using it may alert attackers that they’ve been caught.  
MD5 or SHA-1 condenses a file of any size down to a fixed-length fingerprint. Uniquely identifies a file. De-facto standard way of uniquely identifying samples.  
Hash uses:
- Label a malware sample
- Share the hash with other analysts to identify malware
- Search the hash online to see if someone else has already identified the file

*strings*. 
Any sequence of printable characters is a string. Strings are terminated by a null value (0x00). ASCII characters are 8 bits long, while unicode characters are 16 bits long.  
The `strings` command is native in Linux/OSX, but it is also available for Windows. It prints all the printable strings in a file (3 or more chars long).
```
$> strings bp6.ex_
VP3
VW3
T$@
D$4
99.124.22.1     // [ 4 ]
e-@
GetLayout   // [ 1 ]
GDI32.DLL   // [ 2 ]
SetLayout   // [ 3 ]
M}C
Mail system is invalid.!Send Mail failed to send message.   // [ 5 ]
```

- (1,2) GetLayout and SetLayout are Windows functions
- (3) GDI32.DLL is a Dynamic Link Library
- (4) looks like an IP address
- (5) looks like an error msg

*Obfuscation through packing*  
The code is compressed, like a Zip file. This makes most strings and instructions unreadable. All you'll see is the wrapper (small code that unpacks the file when it is run).  
We can detect the type of packer used with PEID program, but sometimes malware creators use "proprietary" copies to avoid detection.  
Beware! Some PEiD plugins may silently run the malware to identify the packer, so take care of isolating your testing VM.  

*File execution in Windows*  
What happen when you double click an executable file in Windows? The OS (actually the loader) looks in the file to understand what to do.
What’s in the file?
- Code
- Data
- Other resources
- Metadata

All these information need to be organised to be correctly interpreted by the loader.  
Windows uses the **Portable Execution** file format.  
- Used by Windows executable files, object code, and DLLs.  
    - Very convenient! A single file format for several different usage scenarios
    - Means that you treat EXEs and DLLs in a very similar way
- A data structure that contains the information necessary for Windows to load the file
- Almost every file executed on Windows is in PE format

![PE file format](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/09-pe-format.png)

The sections that are most commonly present in an executable are:
- Executable Code Section, named *.text* (Microsoft) or *CODE* (Borland)
- Data Sections, named *.data*, *.rdata*, or *.bss* (Microsoft) or *DATA* (Borland)
- Resources Section, named *.rsrc*
- Export Data Section, named *.edata*
- Import Data Section, named *.idata*
- Debug Information Section, named *.debug*

The names are actually irrelevant as they are ignored by the OS and are present only for the convenience of the programmer.  
Means you can find very different names (e.g. packers use their names).


## Lesson 8 - Models for Threat Intelligence  
Most dangerous attacks are today characterized by
- Precise targeting
- Use of advanced intrusion/obfuscation techniques
- Full control of target (RAT)
- Long-term persistence (APT)

The attacker (threat) has enough motivations/resources/skills to try to attack its target for prolonged periods of time, using several approaches.  

![cyber threat intelligence](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/10-cti.png)  
An effective threat intelligence process has the main purpose of characterizing threats in order to identify valuable preventative controls.  
- Identify attackers
- Profile attackers
- Identify key tactics
- Rebuild playbook
- Replay playbook
- Utilize results

Goals at several levels:
- Strategic: Provide understanding of identified and credible threats, correlated to business impact
- Operational: Enable formulation of approaches to dealing with threats and prioritization of team activity
- Tactical: Provide understanding of how to mitigate threats and enable tools to do the heavy lifting

How do we make intelligence "actionable"?
- We assume the attack is resource constrained and behaves like a rational human being
- Cost factors
    - expertise, time, money, resources
- Success factors
    - target ubiquity, probability, access
- Value for the attacker comes from the possibility of re-using attack methodologies/techniques/tools as much as possible

*Repeatability*: the capability to change the target and have the attack still work with the same success rate.
*Scalability*: the capability to launch the attack against multiple targets with minimal cost per additional target.

Attackers determine the least costly and most valuable attacks based on
- Who are the targets
- Required success rate
- Speed of conversion

Inexpensive, valuable, scalable, or repeatable: Phishing, Credential reuse, Known vulnerabilities with public exploits, Office macros, Spyware, Vendor compromise.  
Costly, valueless, unscalable, or unrepeatable: Web vulnerabilities, 0-day exploits, Known vulnerabilities without public exploits, Embedded devices, Crypto weaknesses, Insider threat.  
The kill chain is not just a way to represent attacks, but rather a methodology to analyze (tentatives of) intrusions to extract actionable information (intelligence).  

The fundamental element of intelligence in this model is the indicator.  
**Indicator**: any piece of information that objectively describes an intrusion.  
Three types of indicators
- Atomic: those which cannot be broken down into smaller parts and retain their meaning in the context of an intrusion. (e.g. IP addresses, email addresses, vulnerability identifiers, etc.)
- Computed: those which are derived from data involved in an incident. (e.g. hash values)
- Behavioral: collections of computed and atomic indicators, often subject to qualification by quantity and possibly combinatorial logic. (e.g. "the intruder initially used a backdoor which generated network traffic matching regular expression at the rate of some frequency to some IP address")  

Indicators can be used to describe/identify various stages of the intrusion using the kill chain as a reference model.  

| Phase | Indicators |
| ----- | ----- |
| Reconnaissance | Benign File: tcnom.pdf (Recipient List) |
| Weaponization | Trivial encryption algorithm: Key 1 |
| Delivery | dn...etto@yahoo.com Downstream IP: 60.abc.xyz.215 Subject: AIAA Technical Committees (Email body) |
| Exploitation | CVE-2009-0658 (shellcode) |
| Installation | C:\...\fssm32.exe C:\...\IEUpd.exe C:\...\IEXPLORE.hlp |
| C2 | 202.abc.xyz.7 (HTTP request) |
| Actions on Objectives | N/A |

The intrusion killchain becomes a model for actionable intelligence when defenses align enterprise defensive capabilities to the specific processes an adversary undertakes to target that enterprise.  
![Course of action](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/11-course-of-action.png)  
Strategies to counteract intrusions:
- Detect: set up detection rules of an indicator for future events. (e.g. rules in an intrusion detection system (IDS), firewall or alert on SIEM)
- Deny: prevent the event from taking place. (e.g. firewall block)
- Disrupt: make the event fail as it is occurring. (e.g. file quarantining or memory protection measures)
- Degrade: slow down the further actions of the attacker. (e.g. bandwidth throttling)
- Deceive: learn more about the intentions of the attacker by making them think the action was successful. (e.g. use an honeypot)
- Destroy: offensive action against the attacker. (think twice about it...)

Recurring attacks from persistent threats require deeper understandings. Compare intrusion indicators to find commonalities.  
Infection points among diverse intrusions may represent common patterns in a long-term campaign. Such patterns can be used to uniquely identify threat actors.  

## Lesson 9 - Basic Analysis

The **Portable Execution** file format starts with a MS-DOS header + stub, just for compatibility. The PE headers contain metadata used to correctly load and execute the file. File content is structured in "sections", each section contains a specific kind of data. The section table describes the sections. Usually at least two sections are present.  
The sections that are most commonly present in an executable are:
- Executable Code Section, named *.text* (Microsoft) or *CODE* (Borland)
- Data Sections, named *.data*, *.rdata*, or *.bss* (Microsoft) or *DATA* (Borland)
- Resources Section, named *.rsrc*
- Export Data Section, named *.edata*
- Import Data Section, named *.idata*
- Debug Information Section, named *.debug*

The names are actually irrelevant as they are ignored by the OS and
are present only for the convenience of the programmer. Means you can find very different names (e.g. packers use their names)

**DOS header + STUB**  
The DOS header occupies the first 64 bytes of the file. It's there in case the program is run from DOS, so DOS can recognise it as a valid executable and run the DOS stub. The DOS stub usually just prints a string like "This program must be run under Microsoft Windows". At the first 2 bytes we have the 'magic signature', `5A4Dh`, or `MZ`. At the end of the DOS header we have a pointer to the PE header, since the DOS STUB doesn't have fixed length.  
![PE Header](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/12-PE-header.png)  

**PE header**  
The first part of the PE header is a signature (like in the DOS header) composed by 4 bytes: `50450000h` ("PE"). After this signature we find the COFF header (20 bytes) and the Optional Header (*not optional for the PE standard, it is needed*) composed by 224 bytes (but it's variable), 96 for the Headers and 128 for the DataDirectory.  
![PE header 2](https://github.com/edoardottt/MSc-CyberSecurity-Sapienza/blob/main/Malware-Analysis-and-Incident-Forensics/resources/images/13-PE-header2.png)  

After the section headers we find the sections themselves.  
In the file on disk, each section starts at an offset that is some multiple of the FileAlignment value found in OptionalHeader. Between each section's data there will be `00` byte padding. When loaded into RAM, the sections always start on a page boundary so that the first byte of each section corresponds to a memory page. On x86 CPUs pages are 4kB aligned, whilst on IA-64, they are 8kB aligned. This alignment value is stored in SectionAlignment also in OptionalHeader.  

**Imports**  
Functions used by a program that are stored in a different program, such as library. Connected to the main EXE by linking.  
Can be linked three ways:
- Statically
    - Rarely used for Windows executables
    - More common in Unix/Linux
    - All code from the library is copied into the executable
    - Makes executable large in size
    - The main way to go if you want to have self-contained code
- Dynamically
    - Most common method
    - Host OSs search for necessary libraries when the program is loaded
- At Runtime
    - Unpopular in friendly programs
    - Common in malware, especially packed or obfuscated malware
    - But also used by software that allows dynamic loading of plugins
    - Connect to libraries only when needed, not when the program starts
    - Most commonly done with the *LoadLibrary* and *GetProcAddress* functions

The PE header lists every library and function that will be loaded. Their names can reveal what the program does e.g. "URLDownloadToFile" indicates that the program downloads something.  

**Common DLLs**:
- `Kernel32.dll`: This is a very common DLL that contains core functionality, such as access and manipulation of memory, files and hardware.
- `Advapi32.dll`: This DLL provides access to advance core Windows components such as Service Manager and Registry.
- `User32.dll`: This DLL contains all the user-interface components, such as buttons, scroll bars and components for controlling and responding to user actions.
- `Gdi32.dll`: This DLL contains functions for displaying and manipulating graphics.
- `Ntdll.dll`: This LL is the interface to the Windows kernel. Executables generally do not import this file directly, although it is always imported indirectly by Kernel32.dll. If an executable imports this file, it means that the author intended to use functionalities not normally available to Windows programs. Some tasks, such as hiding functionality or manipulating processes, will use this interface.
- `WSock32.dll` and `Ws2_32.dll`: These are networking DLLs. A program that accesses either of these most likely connects to a network or performs network-related tasks.
- `Wininet.dll`: This DLL contains higher-level networking functions that implement protocols such as FTP, HTTP and NTP.

Basic Static Analysis of some samples using PE-Studio.
